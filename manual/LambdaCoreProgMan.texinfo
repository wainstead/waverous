\input texinfo   @c -*-texinfo-*-

@comment %**start of header (This is for running Texinfo on a region.)
@setfilename LambdaProgMan.txt
@settitle LambdaCore Database User's Manual
@c Uncomment the following line for two-sided printing.
@c @setchapternewpage odd
@comment %**end of header (This is for running Texinfo on a region.)

@iftex
@finalout
@end iftex

@ifinfo
@format
@sp 5
		 ********************************************
		 * LambdaCore Database Programmers's Manual *
		 ********************************************
				       
			   For LambdaMOO version 1.3
				 May 1991
				       
			    by Mike Prudence (blip)
			    by Simon Hunt (Ezeke)
			    by Floyd Moore (Phantom)
			    by Kelly Larson (Zaphod)
	                    by Al Harrington (Geezer)
@sp 4
Copyright @copyright{} 1991  Mike Prudence, Simon Hunt, Floyd Moore,
Kelly Larson, Al Harrington.
@end format

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@ignore
Permission is granted to process this file through TeX and print the results,
provided the printed document carries copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions, except
that this permission notice may be stated in a translation approved by the
author.
@format
@sp 5
@end format
@end ifinfo

@titlepage
@title LambdaCore Database Programmer's Manual
@subtitle For LambdaMOO version 1.3
@subtitle July 1991
@author Mike Prudence (blip)
@author Simon Hunt (Ezeke)
@author Floyd Moore (Phantom)
@author Kelly Larson (Zaphod)
@author Al Harringtom (Geezer)
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1991 Mike Prudence, Simon Hunt, Floyd Moore,
Kelly Larson, Al Harrington.

Copies of the electronic source for this document can be obtained using
anonymous FTP on the Internet.  At the site @code{belch.berkeley.edu} the
files are @code{pub/moo/LambdaMOO/LambdaCoreProgMan.*}; several different
file formats are provided, including Texinfo, plain text, and Postscript.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions, except
that this permission notice may be stated in a translation approved by the
author.
@end titlepage

@unnumbered Introduction

The LambdaCore database provides the facilities needed to make a
LambdaMOO server useful for Multi User Adventuring.  If you compare the
LambdaMOO server to a piece of computer hardware, then LambdaCore is the
operating system needed to allow the user to do useful work.

This document gives a rundown on the elements of the LambdaCore
database, and provides details of each of the verbs used by the
database.  It also provides source for some of the verbs, to aid
understanding and provide extra information.  

The user is assumed to have read the two companion manuals to this one,
@dfn{The LambdaMOO Programmer's Manual} and @dfn{The LambdaCore User's
Manual}.  An understanding of MOO concepts, the MOO language and the
facilities provided by the LambdaCore database is needed to follow the
explanations given in this document.

@chapter The LambdaCore Classes

The LambdaCore database provides several basic classes that are used to
define the virtual world.  It is these classes that provide the
@dfn{core} of any MOO database built on the LambdaCore database.  As
well as defining obvious things like players, rooms and exits, the
classes also provide all the commands used to interact with the
database, and several utility functions for use by the MOO programmer
writing his or her own verbs.

The LambdaCore classes can be divided into two categories:

@itemize @bullet
@item
Generics: These are classes containing generic objects, for example
players, rooms, exits and so on.  If a new generic object is created, it
would be placed in this list.
@item 
Utilities: These are classes containing utility verbs that can be used
by other verbs.  Example include string utilities, trig functions etc.
@end itemize

The sections that follow describe the LambdaCore classes in detail,
providing insight into what each verb and property is used for, and some
idea of how they should be used in your own MOO programs.

@section The LambdaCore Generic Classes

The following generic classes are available in the LambdaCore database:

@display
@table @code
@item The Root Class ($root_class)
This is the basic class from which everything else in the database is
descended.  It defines basic operations and properties on an object.

@item The Generic Room ($room)
This class is the parent for all the rooms in the database.

@item The Mail Distribution Center ($mail_room)
This is a special class used to define a room for dealing with MOO mail.
It is a child of the generic @code{Room} class.

@item The Generic Mail Recipient 
To be written.

@item The Generic Editor's Office ($editor)
This is a special class used to define a room used for program editing.
It is a child of the generic @code{Room} class.

@item System Object (#0)
This is the keystone object for the database.  It holds various important
system properties, as well as pointers to the various other classes and
objects that are system-wide.

@item The Generic Thing ($thing)
This class defines a TinyMUD style object, that is, something that can
be picked up and put down.  It defines various messages related to
taking and dropping the object.

@item The Generic Container ($container)
This is a child class of the @code{Thing} class.  A container is an
object that can have other objects placed within it.

@item The Generic Note ($note)
A note is a child class of the @code{Thing} class.  It is used to store
text messages, which may be encrypted.  A note can only be recycled by
the owner.

@item The Generic Letter ($letter)
A letter is a child class of the @code{Note} class.  It provides the
same facilities, but also has a @code{burn} verb which the recipient can
use to recycle the letter.

@item The Generic Player ($player)
This is the class from which all players are descended.

@item The Generic Programmer ($prog)
This is a child of the @code{Player} class used for players that are MOO
programmers.  It defines a set of verbs that are useful for programming
activities. 

@item The Generic Wizard ($wiz)
This is a child of the @code{generic programmer} class, used for
wizards.

@item The Generic Exit.  ($exit)
This class defines a generic exit used to link one object of class
@code{Room} to another object of class @code{Room}.  It defines a
number of messages that may be generated when an exit is used.
@end table
@end display

@subsection The Root Class

The root class is the base class from which all objects are descended.
It is the keystone of the database and defines fundamental verbs and
properties common to every object.  If you are a programmer (ie, you
have a player object with the @dfn{programmer} bit set) you can examine
the properties and verbs of the root class using the command

@example
@@show $root_class
@end example

@noindent
You can examine the code for a verb on the class by using, for
example, the following command.

@example
@@list $root_class:description
@end example

@noindent
This lists the program definition for the verb
@code{$root_class:description}.  An interesting point to note is that
this code can be changed by the owner - in this case the Wizard - to
provide any functionality desired.  This configurability of the basis of
the whole LambdaCore database allows a large degree of flexibility in
the way the LambdaMOO server is used.  It also allows for very subtle and
perplexing problems. Care must be taken when editing definitions on any
of the fundamental classes, the @code{$root_class} in particular.
However, as the base classes of the LambdaCore database have been
thoroughly tested and debugged, there should be very little need for any
changes by the average database administrator.

The following section lists the verb and property definitions for the
@code{$root_class}.  For each verb, a description of it's function is
given, along with any interesting points.  The intent is to present each
verb in such a way that it is possible to grasp the whole picture,
rather than just looking at the individual brushstrokes.

@deftypefn Verb string description ()
The @code{:description} verb on any object is supposed to return a
string or list of strings describing the object in the detail someone
would notice if they were specifically looking at it.  

The default implementation of the "look" command (defined on the
@code{$room} class), prints this description using the @code{:look_self}
verb on the object.  @code{:look_self} uses @code{:description} to
obtain the text to display.
@end deftypefn

@deftypefn Verb none describe (@var{value})
The @code{:describe} verb is used to set the description property of an
object.  This is only allowed if we have permission, determined using
the @code{$perm_utils:controls()} verb.  By overriding this verb and the
@code{:description} verb, it is possible to completely change the
representation of an object description.  This is done invisibly to
anyone outside the object, as long as you adhere to the same interface
to @code{:description} and @code{:describe}.
@end deftypefn

@deftypefn Verb none look_self ()
The @code{:look_self} verb on any object is used to @code{:tell} another
object what this object looks like, in detail.  This verb makes use of
the @code{:description} verb on the object to obtain a string or list of
strings to print.  It would be possible to override this verb to produce
a special description for an object.  However, any other verbs that use
the @code{:description} verb of the object will not see the extra
information added by the overriding function.  The @code{$room} class
overrides this verb with code to print the room @code{name} and a list
of objects that are in the room.
@end deftypefn

@deftypefn Verb none tell (string @var{strings}, @dots{})
This verb is used to send a message from one object to another.  The
@code{$root_class} definition of this verb tests to see if the object is
a player, and if it is, uses the @code{notify} primitive to print the
argument list on the player's screen, if they are connected.  However,
this verb can be overridden to allow arbitrary objects to pass messages
between each other, or to augment the way the message is handled.

One simple example is that of an object that listens to everything that
happens in a room.  Every verb that needs to send text to players uses
the @code{:tell} verb.  If an object has it's own @code{:tell} verb, it
too will be able to act upon the messages sent between objects in a
room.

The @code{$player} class overrides this verb to filter messages in two
different ways, as show below:

@example
if (typeof(this.gaglist) != LIST || !(player in this.gaglist))
  if (player != this && this.paranoid == 1)
    pass("<", player.name, "(", player, ")> ", @@args);
  else
    pass(@@args);
  endif
endif
@end example

@noindent
Firstly, if the message comes from a player that we don't want to listen
to - the player has been @dfn{gagged} - then the message is thrown away.
Secondly, if the player is being @dfn{paranoid}, and the message is not
from ourselves, it is prefaced with the name of the originating object.
The @code{pass} primitive is used to allow the @code{:tell} verb of the
parent class to send the message after it has been modified.
@end deftypefn

@deftypefn Verb none moveto (obj @var{where})
This verb is used to change the location of an object to be @var{where}.
The built-in function @code{move()} is used by this verb. Any
error codes generated by it are returned by this function.  This verb is
intended to be used by any other verbs that must move an object to
another location.

One important point to note is that this uses the
@code{set_task_perms()} primitive to set the task permissions to those
of the thing that is being moved.

Again, by overriding the verb definition on an object, it is possible to
augment or change the way an object is moved.  For example, you could
keep a list of places visited by simply recording the @var{where}
objects in a list every time this function is called.
@end deftypefn

@deftypefn Verb num accept (obj @var{thing})
This verb is used to control what objects are permitted to be placed
@dfn{inside} other objects.  If this verb returns @samp{0}, then the
object @var{where} cannot be moved into this object.  Conversely, if the
verb returns a non-zero value, the object is allowed to be placed inside
this object.  The verb is called by the server when it executes a
@code{move()} primitive.

The @code{$root_class} definition returns a zero value.  In this case,
no objects are allowed inside any objects that are children of the
@code{$root_class}.  The @code{$room} class definition provides for a
flexible scheme using various different criteria, as shown in the
following code :

@example
what = args[1];
return this:is_unlocked_for(what) && 
       (this.free_entry || 
       what.owner == this.owner || 
       (typeof(this.residents) == LIST && what in this.residents));
@end example

Starting at the top of the conditional expression, we see the locking
condition being checked.  If the room lock forbids this object to enter
the room, then the @code{:accept} verb returns zero.  

If this is not the case, then we consider the value of the
@code{free_entry} property.  If this is set to a non-zero value, then
the object is allowed to enter the room.

If the owner of an object is the owner of a room, the object is allowed
to enter.

Finally, if a @code{residents} list is defined in the room, and the
object is in the list, then it is allowed to enter.

This complex set of conditions shows how an arbitrary set of criteria
can be applied to the movement of objects into other objects.
@end deftypefn

@deftypefn Verb obj match (string @var{name})
This verb is used to find things that are located within this
object.  It tries to match @var{name} to something in the contents list
of this object, using object names and object aliases.  This verb uses
the @code{$string_utils:match()} verb to do the actual searching.  If a
match is found, the object that matched is returned.  If more than one
object matches, then @code{$ambiguous_match} is returned.  If no match
is found, then @code{$failed_match} is returned.
@end deftypefn

@deftypefn Verb none exam*ine ()
This prints out some useful information about the object to the player.
It is provided as a player command, to allow every player to determine
basic information about any other objects they come across.  For
example,

@example
>exam #0
The System Object (#0) is owned by Wizard (#2).
Aliases:  The, Known, and Universe
(No description set.)
@end example

The idea is to allow every player to discover the owner, full name,
description and aliases of any object.

If you control the object, the lock for the object is shown.  If the
object has other objects inside it, then the contents list is printed
out, too.  If the object has verbs defined on it, then these verbs are
listed, provided they are readable, and have not been hidden by setting
the argument specifiers to the triplet @samp{this}, @samp{none}
@samp{this}.
@end deftypefn

@deftypefn Verb none tell_lines (list @var{strings})
This outputs out the list of strings @var{strings} to the object, using the
@code{tell} verb for this object.  Each string in @var{strings} is
output on a separate line.
@end deftypefn

@deftypefn Verb num set_name (string @var{value})
This verb sets the name of the object to @var{value}.  It returns `1' if
the name was set to the @var{value} successfully, otherwise it returns
`0'.  This verb, and the @code{:title} verb are used to control access
to the @code{name} property of an object.  
@end deftypefn

@deftypefn Verb num is_unlocked_for (obj @var{thing})
Returns `1' if the object is unlocked for the argument.  If the value of
@code{this.key} is zero, the object is unlocked.  If this is not the
case. the verb @code{$lock_utils:eval_key()} is used to determine the
result.
@end deftypefn

@deftypefn Verb string title ().
This verb is used to get the @code{name} property of this object.  

One example where it might be useful to redefine this verb is if you
want to add an honorific or descriptive phrase to the end of your name.
By overriding the @code{:title} verb, you can append anything you like
to the @code{:name} property of the object.
@end deftypefn

@deftypefn Verb none recycle ()
This verb contains no code for the @code{$root} class.  It is called by
the @code{recycle()} primitive just before an object is recycled.  This
is useful to make sure that recycling objects does not leave the
database in a strange state.  For example, the @code{$exit} class uses
the @code{:recycle} verb to remove the exit from the the @dfn{entrance}
and @dfn{exit} lists of its destination and source rooms.
@end deftypefn

@deftypefn Verb string titlec ()
This verb performs the same function as the @code{title} verb, but
returns a capitalised version of the @code{name} property of the object,
using the @code{$string_utils:cap_property} verb.
@end deftypefn

@deftypefn Verb none eject ()
This verb is used to remove something from the contents of an object.
The owner of an object, or a wizard, can use this verb to eject a victim
from inside the object.  The victim is sent to @code{$nothing}, for most
objects, or to @code{$player_start} if the victim is a player.
@end deftypefn

@noindent
The root class defines a few basic properties that every object has.
The verbs discussed above make reference to these properties - as well
as the built in properties @code{name}, @code{owner}, @code{location},
@code{contents}, @code{programmer}, @code{wizard}, @code{r} and
@code{w}. 
The following properties are defined for the root class:

@defvr Property key
This is used to determine what, if anything, an item is locked to.
@end defvr

@defvr Property aliases
This gives a list of the alternative names that can be used to refer to
an object. The value of this property should be a list of strings, the
various alternatives for naming the object.  Note that the name of the
object in question should be included in this list, because the built in
name matcher uses only the @code{aliases} property when searching for
matches.
@end defvr

@defvr Property description
This is a string or list of strings giving the description of the object
- what we see when we @code{look} at the object.
@end defvr

@subsection The Room Class

The @code{Room Class} is the basic class from which all the @dfn{rooms}
in the virtual world are descended. It is one of the very basic classes
essential to constructing a virtual world; an @code{exit} is the other
essential class.

A room can be thought of as a container for players and objects.  It
can have a number of exits that connect it to other rooms.   These exits
are directed; they lead @dfn{from} one room @dfn{to} another room.  For
a two way passage to exist, two exits are needed, going in opposite
directions.

The room class defines a lot of verbs, which are used to provide
an interface to the properties of the room.

One special point is worth noting about rooms and exits.  An exit can
have an arbitrary name - indeed, this is the usual case.  In order for
the room to recognise the exit name, and match it up with an exit that
exists in the room, some form of @dfn{catchall} mechanism is used.  If a
player types a sentence that the parser cannot match with anything, it
executes a verb called @code{:huh} in the current room, if one exists.

When this happens, the @code{:huh} verb is free to take the player's
sentence, search for a valid exit, and act accordingly.  This mechanism
provides a very flexible arrangement for dealing with exits, and also
allows a degree of player help to be added.  If a close match to a
command is found, the @code{huh} verb could detect this and provide a
useful response that would help the player construct the correct
sentence.

The following section lists the verbs defined for the @code{$room}
class.  Those verbs which are more properly described as player commands
are detailed in a preceding section.

@deftypefn Verb none confunc ()
This verb is called by the LambdaMOO server when a player connects in a
room.  The action coded into the @code{$room} class simply shows the
player what the room looks like (using the @code{:look_self} verb of the
room) and tells everyone else in the room that the player has connected.
@end deftypefn

@deftypefn Verb none disfunc ()
This verb is called by the LambdaMOO server when a player disconnects
from the game.   The @code{$room} class definition of this verb moves
the player home if s/he is not already there, using the @code{:moveto}
verb on the player.  One possible enhancement of this verb, already
implemented in some MOOs, is to include a time delay between
disconnection and movement of the player to his/her home.  This would
allow some tolerance of disconnection due to network problems.
@end deftypefn

@deftypefn Verb none say (string @var{message})
This verb provides one of the basic ways in which players communicate.
The action of the @code{:say} verb is very simple: it @code{:tell}s the
player what s/he has just said, and tells everyone else what the player
said. The text spoken is passed to all the objects in a room, not just
the players, through the @code{:tell} verbs on the objects in the room.

By overriding this verb, it is possible to provide all sorts of effects
that work on everything said in the room.  For example, you could
redirect messages to other rooms, or repeat messages to provide
cavernous echoes.
@end deftypefn

@deftypefn Verb none emote (string @var{message})
This verb is used for the @dfn{pose} type of interaction with other
players.  It functions in a similar way to the @code{:say} verb, but
instead places the player's name at the front of the text.  The actual
output is done in two stages.  The @code{:emote} verb is responsible for
telling the player the action s/he has just performed.  The
@code{emote1} verb is then called to tell the other objects in the room
of the @code{pose} action.  This provides a two stage mechanism; either
or both of the verbs can be overridden to provide special effects.
@end deftypefn

@deftypefn Verb none emote1 (string @var{message})
This verb is invoked by the @code{emote} verb to send the @dfn{emote}
text to the other objectss in the room.  By overriding this verb, it is
possible to create special effects for @code{emote} actions that are
only seen by the other people in a room.  @code{:emote1} uses
@code{$room:announce} to send it's message.
@end deftypefn

@deftypefn Verb none announce (string @var{message})
This verb is a general purpose verb used to send a message to every
object in the room except the player that invoked it.  This is intended
to be the way other verbs pass messages to objects in a room.  For
example, when an exit is activated, it uses @code{:announce} to inform
the other players in the room of what has happened.
@end deftypefn

@deftypefn Verb none announce_all_but (list @var{@@args})
This general purpose verb is used to send a message to everyone in the
room @dfn{except} a particular object.  This can be used in situations
where we wish to present one view to the world in general, and another
view to a particular object, normally a player.  Another common usage is
to prevent robots that trigger actions based on a redefined
@code{:tell()} verb on themselves from recursing, using something like

@example
place:announce_all_but(this, "message");
@end example
@end deftypefn

@deftypefn Verb none huh (string @var{sentence})
This verb is a stub used to call the @code{huh2} verb.  It is called by
the LambdaMOO server when it can't match a sentence given to it by a
player.  The server calls @code{:huh} with @code{verb} equal to the
actual verb in the erroneous command line.  This means it is not
possible to use @code{pass()} if you override @code{:huh} in a room; it
would pass control up to a verb on the parent named @code{verb}, i.e.,
whatever the verb was on the command line.  This, by definition, doesn't
exist.  To get around this, and allow you to use @code{pass()} to get
the default @code{:huh} behaviour, @code{:huh} calls @code{:huh2}.  You
should override @code{:huh2} if you wish to be able to use @code{pass()}
to get the default @code{:huh} behaviour.
@end deftypefn

@deftypefn Verb obj match_exit (string @var{exit})
This verb is used to determine if @var{exit} is the name of an exit
leading out of the room.  It performs a simple string match on the names
and aliases of the objects in the @code{exits} list stored as a property
of the room.  The intent here is to allow for more sophisticated
matching algorithms to be implemented.  One might even go so far as
implementing a fuzzy matching scheme, to allow for player misspellings.
If a successful match is made, this signifies that an exit with the name
@var{exit} leads from this room.  It's object number is returned.  If
more than one match is found the value @code{$ambiguous_match} is
returned. If no match is found, the value @code{$failed_match} is
returned.
@end deftypefn

@deftypefn Verb num add_exit (obj @var{exit})
This verb is used to add @var{exit} to the list of exits leading out of
the room.  This verb, and the @code{:match_exit} verb provide the
interface to the room exits list.  The way in which exits are stored,
removed and matched has been separated from the interface so that
different implementations of the @dfn{exits} concept can be used in
different sub classes of the @code{$room} class.

If it is not possible to add @var{exit} to the room's exit list
(normally because the object that invoked the verb does not have the
required permission) then the verb returns `0'.  Otherwise, a successful
addition returns `1'.
@end deftypefn

@deftypefn Verb none tell_contents ()
This verb tells us what things are visible in the room.  It goes through
the @code{contents} list of the room, and if it is not dark, prints the
name of the object in a nicely formatted way.  Three different formats
are available depending on the value of the @code{ctype} property of the
room.  These are best illustrated by example.

Consider the a room in the LambdaCore database.  With a @code{ctype}
value of three (the default), the @code{tell_contents} verb produces the
following output:

@example
You see a newspaper and a fruitbat zapper here.
Wizard is here.
@end example

@noindent
This format provides the separation of player objects from other
objects, and provides the list in a way that fits in with the idea of a
virtual reality.  It is easy to read, and looks natural.

If the @code{ctype} value is changed to 2, the following is printed:

@example
You see Wizard, a newspaper, and a fruitbat zapper here.
@end example

@noindent
This format treats players and objects the same, and is useful if you
wish to hide the fact that an object is not a player, or vice versa.

With a @code{ctype} value of one, the following is seen:

@example
Wizard is here.
You see a newspaper here.
You see a fruitbat zapper here.
@end example

@noindent
This format provides the advantage of having each item on a separate
line, although it does mean that rooms with a large number of objects in
might have excessively long contents lists.

Finally, with a @code{ctype} of zero, the following is seen:

@example
Contents:
  Wizard
  a newspaper
  a fruitbat zapper
@end example

@noindent
This is the sort of listing obtained in traditional TinyMU* games.  It
benefits from clarity, but is not as natural as any of the other forms.

If a value of @code{ctype} is set that is outside of the range zero thru
three, then no contents list is printed.  This can be useful if you want
to handle the room contents listing as part of the description of the
room.  Also, if the @code{dark} property of a room is set to a non-zero
value, then no contents list is printed.

As usual, this verb can be overridden to provide special effects.  For
example, you could apply a filter so that certain objects do not appear
in the printed contents of a room, even if they appear in the contents
list.  This can be use to hide objects, for example, as part of a
puzzle, or to vary how objects are seen, for example if you are looking
through water at something.
@end deftypefn

@deftypefn Verb obj match_object (string @var{name})
This is the verb used to search the player's locale for an object that
has the name or pseudonym @var{name}.  This verb handles mapping of
@code{me} to the player object, @code{here} to the player's location as
well as the use of @code{#<number>} to refer to a particular object.  If
none of these cases match, the verb searches the room contents and the
players contents (or possessions) for a match.  If a match is found,
then the unique object number is returned.   If @var{name} matches more
than one object, then @code{$ambiguous_match} is returned.  If no match
is found, then @code{$failed_match} is returned.

The verb @code{:match_object} is the one to use to map names of objects
to object numbers, when referring to objects that the player is able to
@dfn{see} in his current location.  This includes objects that the
player might be carrying, but does not include objects that are
@dfn{contained} in other objects.
@end deftypefn

@deftypefn Verb none @@exits ()
This verb is a player command used to print a list of the exits in a
room.  It can only be used by the owner of the room.  The verb simply
runs through the list of defined exits, stored in the property
@code{exits}, and prints the exit name, object reference number,
destination name, and exit aliases.
@end deftypefn

@deftypefn Verb none look_self ()
This verb overrides the @code{$root_class} definition of the verb
@code{:look_self} in order to provide a fuller description of a room
than the @code{description} property gives.  This verb prints the room
name, followed by the room's @code{description} property, and then the
list of contents of the room, using the room's @code{:tell_contents}
verb.  This is what the player would see if he was looking at the room.

The @code{description} property of the room is actually printed
by using the @code{pass()} primitive to invoke the parent verb
@code{:look_self}).  Changes in the way an object's description is stored
by the root class are invisible to this verb, because of the way
@code{pass} is used.
@end deftypefn

@deftypefn Verb num accept (object @var{thing})
This verb overrides the @code{$root_class} definition.  The
@code{$room_class} definition provides for a flexible scheme using various
different criteria.  The idea is to allow the builder flexibility in
preventing objects from moving into the room. The following code shows
how the @code{$room:accept} verb decides whether to allow @var{thing} to
enter the room or not.

@example
what = args[1];
return this:is_unlocked_for(what) && 
       (this.free_entry || 
       (what==this.blessed_object&&task_id()==this.blessed_task) ||
       what.owner == this.owner || 
       (typeof(this.residents) == LIST && what in this.residents));
@end example

Starting at the top of the conditional expression, we see the locking
condition being checked.  If the room lock forbids this object to enter
the room, then the @code{:accept} verb returns zero.  

If this is not the case, then we consider the value of the
@code{free_entry} property.  If this is set to a non-zero value, then
the object is allowed to enter the room.  This is used to provide public
places, where anything and everything is allowed to enter.  The default
value of this property is @code{1}.

If the object has been @dfn{blessed} for entry into this room, and the
task that is moving the object is the same as the task that requested
the blessing, then the object is allowed to enter.  Refer to the
@code{:bless_for_entry} verb for further details on the concept of
blessed objects.

If the owner of an object is the owner of a room, the object is allowed
to enter.  This is a general rule used as a catch-all case.  It can be
overridden by specifically locking against an object, but as a rule, it
is desirable for objects owned by the room owner to be allowed to enter.

Finally, if a @code{residents} list is defined in the room, and the
object is in the list, then it is allowed to enter.  This concept can be
used to define a set of objects that are allowed to enter the room
without specifying a long and complex locking condition.
@end deftypefn

@deftypefn Verb num add_entrance (obj @var{entrance})
This verb functions similarly to the @code{:add_exit} verb, but applies
to @code{$exit} objects that lead @dfn{into} the room.  If we imagine an
@code{$exit} object as a flexible tube connecting two rooms, then the
concept of specifying both ends of the tube seems natural.  It is not
usual to search the entrance list for a match, as you would with the
exit list, but the concept of an entrance is included to cover
unexpected cases.

If it is not possible to add @var{entrance} to the room's entrance list
(normally because the object that invoked the verb does not have the
required permission) then the verb returns @samp{0}.  Otherwise, a successful
addition returns @samp{1}.
@end deftypefn

@deftypefn Verb none bless_for_entry (obj @var{thing})
This verb is called by an exit to allow an object special permission to
enter a room.  Two properties on the room store @var{thing} and the
@code{task_id} of the calling task.  The idea behind @dfn{blessed}
objects is to allow an object temporary permission to enter.  The
permission is only granted if the request is made by an object that is
an entrance into the room.

The idea here is that a normally inaccessible room can be entered
providing you use an exit that leads into the room.  In addition, the
task ID of the task that asked for the @dfn{blessing} is stored, so that
there is no way an object can become blessed, and then later gain entry
to the room.  The object being blessed is only allowed to enter once per
blessing.  Once the object has moved into the room, it's @dfn{blessed}
status is removed by resetting the @code{blessed_object} property in the
room to @code{$nothing}.
@end deftypefn

@deftypefn Verb none @@entrances
This verb is a player command used to list the entrances to the player's
current location.  Only the owner of a room may list it's entrances.
For every object kept in the room's @code{entrances} list, the exit name,
object reference number and aliases are displayed to the player.
@end deftypefn

@deftypefn Verb none go (list @var{args})
The verb is a player command used to move from one room to another.  One
special feature of this command is that it allows the player to string
together a number of different movement commands into one use of the
@samp{go} command.  This can save typing when we know where we want to
go.  The code for this verb is shown below:

@example
for dir in (args)
  exit = player.location:match_exit(dir);
  if (exit < #0)
    player:tell("Go where?");
  else
    exit:invoke();
  endif
endfor
@end example

This simply moves through the list of exits given in @var{args},
matching the exit name in the current room, and invoking the exit if a
valid match is found.
@end deftypefn

@deftypefn Verb none look ()
This verb is a player command used to look at various things in the
player's current location.  It can be used meaningfully in other verbs,
however, if the verb is called with no arguments.  In this case, it
calls the @code{:look_self} on the room which the verb was invoked on.
You could use this verb to print the description of a room you are not
in, but it is stylistically better to use the @code{:look_self()} verb
of the room.

If a preposition is supplied, via this verb being invoked as a command,
and the preposition is not @samp{on} or @samp{in}, then the verb
attempts to match the direct object with something in the room.  If the
match succeeds, the @code{:look_self} verb of the matched object is
called to tell the player what the object looks like.

If the preposition is @samp{on} or @samp{in}, then the player wishes to
look inside a container of some sort, be it a member of the
@code{$container} class, or in a player's inventory, for example.  An
attempt is made to match the indirect object with something in the room.
If it succeeds, then an attempt is made to match the direct object with
something inside the container previously matched.  If this final match
is made, the @code{:look_self} verb of the matched object is invoked to
print it's description.

If the direct object is the empty string, @samp{""}, then the
container's @code{:look_self} verb is called to print it's description. 

Any ambiguous or failed matches produce suitable error messages.
@end deftypefn

@deftypefn Verb none announce_all (list @var{@@args})
This verb is another general purpose verb used to send a message to
every object in the room.  It is used for messages that we wish everyone
to see, with no exceptions.
@end deftypefn

@deftypefn Verb none enterfunc (obj @var{thing})
This verb is invoked by the LambdaMOO server when an object moves into a
room, as part of action of the @code{move} primitive.  The actions taken
for a room are very straightforward.  If @var{thing} is a player object,
then we tell the player where s/he has moved into using the
@code{$room:look_self} verb on the room.  If the object is the
@dfn{blessed_object} for this room, then the @code{blessed_object}
property for the room is reset to @code{$nothing}.  For further details
on @dfn{blessed objects}, refer to the description of
@code{$room:bless_for_entry}.
@end deftypefn

@deftypefn Verb none exitfunc (obj @var{thing})
This verb is invoked by the LambdaMOO server when an object is moved out
of a room, as part of the action of the @code{move} primitive.   The
action defined for the @code{$room} class is to do nothing.  

This verb, and the @code{:enterfunc} verb, can be used for a variety of
effects that need to take note of objects moving in and out of rooms.
For example, consider a @dfn{torch} object that casts light on it's
surroundings.  When the torch is moved out of a room, the light that is
casts moves with it.  This can be tackled using the room's
@code{exitfunc}, which could check if the object leaving is a torch, and
if it is, the room could become dark.   Similarly, when the torch enters
a room, the @code{enterfunc} can be used to detect this, and brighten
the room accordingly.
@end deftypefn

@deftypefn Verb num remove_exit (obj @var{exit})
This verb performs the opposite function to the @code{:add_exit} verb.
It removes @var{exit} from the room's list of exits. If it is not
possible to remove @var{exit} from the room's exit list (normally
because the object that invoked the verb does not have the required
permission) then the verb returns @samp{0}.  Otherwise, a successful addition
returns @samp{1}.
@end deftypefn

@deftypefn Verb num remove_entrance (obj @var{entrance})
This verb performs the opposite function to the @code{:add_entrance} verb.
It removes @var{entrance} from the room's list of entrances. If it is not
possible to remove @var{entrance} from the room's entrance list (normally
because the object that invoked the verb does not have the required
permission) then the verb returns @samp{0}.  Otherwise, a successful addition
returns @samp{1}.
@end deftypefn

@deftypefn Verb none @@add-exit
This is a player command used to add an exit to the current room.  This
is normally used when someone else has created an exit they want to lead
out of a room you own.  The verb matches the direct object string with
an object in the room to get the object reference number for the exit.
If the object found is not a descendant of the @code{$exit} object, the
verb is aborted with an error.

Otherwise, if the destination of the exit is readable and leads to a
valid room, an attempt is made to add the exit using the room's
@code{:add_exit} verb.  If this fails, a suitable error message is sent
to the user.
@end deftypefn

@deftypefn Verb none @@add-entrance
This is a player command used to add an entrance to the current room.
This follows much the same sequence as for the @samp{@@add-exit}.  An
attempt is made to match the direct object supplied with an object in the
room.  If this fails, the verb is aborted with a suitable error message.

Otherwise, if the object found is a descendant of the @code{$exit}
class, then the exit is checked to make sure it goes to this room.  If
this is the case, then the exit is added as an entrance using the room's
@code{:add-entrance} verb.
@end deftypefn

@deftypefn Verb none recycle ()
This verb is called by the LambdaMOO server when a room is recycled.
When a room is recycled, something has to be done with the room's
contents, both players and objects, to stop them ending up in
@code{$nothing}.   This is done by trying to move everything @dfn{home}.
The code to do this is shown below:

@example
for x in (this.contents)
  if (is_player(x))
    if (typeof(x.home) == OBJ && valid(x.home))
      x:moveto(x.home);
    endif
    if (x.location == this)
      move(x, $player_start);
    endif
  elseif (valid(x.owner))
    x:moveto(x.owner);
  endif
endfor
@end example

@noindent
The main loop goes through the complete contents list of the room.  If
the object is a player, then it is moved home, using it's @code{:moveto}
verb, or to the @code{$player_start} room, using the @code{move()}
primitive.  All other objects are moved to the inventories of their
owners.

Note that if the attempt to move an object fails, then no action is
taken.  The server will place all objects still in the room into
@code{$nothing} when the room is recycled.
@end deftypefn

@deftypefn Verb none @@lastlog ()
@deftypefnx Commabd none @@lastlog (@var{player})
This verb is a player command used to list the times that players last
connected to the MOO.  If @var{player} is supplied, by invoking the verb
as a command, only the last connect time for that player is shown.

If no argument is supplied, the verb uses the @code{players()} primitive
to return a list of all players in the database.  It then looks at each
players @code{last_connect_time} property, and places a particular list,
depending on whether the player conncted within the last day, week or
month or longer.

When all players have been placed in one or other of the lists, they
are printed out, along with the exact connect time as found in the
player's @code{last_connect_time} property.
@end deftypefn

@deftypefn Verb none n*orth/e*east/w*west/s*south ()
@deftypefnx Verb none northwest/northeast/southwest/southeast ()
@deftypefnx Verb none up/down ()
In general, when a player wants to move out of a room using an exit,
the recognition of the exit name is done by the @code{:huh} and
@code{:huh2} verbs for the room.  However, to cope with the most common
cases, verbs are defined for each of the compass directions and
@code{up} and @code{down}.  The code for these verbs is the same, and is
shown below as an example:

@example
exit = this:match_exit(verb);
if (valid(exit))
  exit:invoke();
elseif (exit == $failed_match)
  player:tell("You can't go that way.");
else
  player:tell("I don't know which '", verb, "' you mean.");
endif
@end example

What this does is check to see if the exit is defined for the room.  If
it is, then the exit is @code{:invoke}d.  If not, a suitable message is
sent to the player.

This case is included simply to speed up processing for certain common
cases.
@end deftypefn

@deftypefn Verb none explain_syntax (string @code{verb})
This verb is used to provide helpful information to the player should
s/he fail to enter a command correctly.  It is called by the
@code{:huh2} verb as a last resort to process the player command.  The
verb follows the parser's search path for verbs looking for a match with
@var{verb}.  If one is found, this means that the parser rejected the
match because the argument's did not match.  

Having established this, @code{:explain_syntax} compares the user input
to the verb argument definition, and prints some explanatory text to try
and help the player enter a correct command.  This verb usually catches
mistakes such as entering the wrong preposition, or forgetting to use an
indirect object.  It is provided as part of the @code{$room} class to
allow other room subclasses to provide more specific help for certain
verbs defined in their rooms, if the user should make an error trying to
use one of them.
@end deftypefn

@deftypefn Verb none huh2 (list @var{args})
This verb is called by the @code{huh} verb to handle commands that the
parser couldn't sensibly pass to another object.  In the case of a room,
the verb covers a number of different possibilities.  First, the
sentence is checked to see if it matches any of the exits that lead out
of the room.  This is done using the @code{match_exit} verb.  If a
matching exit is found then the @code{:invoke} verb for the exit is
called, which causes it to be activated.  This provides for a flexible
approach to handling exits.

If this does not produce a sensible match, then the verb is treated in
one of two ways.  If it starts with an `at' (@@) character, then we
attempt to match the remainder of the verb in the sentence with a
message field on the direct object.  A message field is a property whose
name ends in @code{"_msg"}. If a match is found, then this is treated as
a field setting command.  This approach is used to avoid having to
define a verb for every message field that can exist on an object.  It
also allows players to add extra message fields to objects simply by
ending the name of the property with @code{"_msg"}.  For example, if you
define a message on an object called @code{foobar_msg} then you can set
the message with the command

@example
@@foobar <object> is <message text>
@end example

If the verb does not start with an `at' (@@) character, then we call the
@code{:explain_syntax} verb.  This tries to match the verb with a verb
defined on the player, room, direct object (if any) and indirect object
(if any).  If a match is found, the syntax of the verb (ie, number and
type of arguments and prepositions) is checked, and a useful message
sent to the player.

This approach is taken to provide flexibility.  By not placing this sort
of code within the server, the LambdaMOO administrator has the choice of
changing the way erroneous commands are handled.  One application could
be an augmentation of the basic @code{huh} action to log failed commands
in a list somewhere.  This mechanism, long used in other MUDs, can
provide a builder with an idea of what other players have tried (and
failed) to do in his or her areas.
@end deftypefn

@deftypefn Verb none @@eject @var{object}
This verb is a player command used to remove unwanted objects from
places that you own.  It can be used to remove objects, which are sent
to @code{$nothing} and players, which are sent to @code{$player_start}. 

The verb first matches the supplied @var{object} with something in the
room.  If a match is found, and the player controls the current room,
then the ejection messages are printed, and the victim's @code{:eject}
verb is invoked to actually remove the object.
@end deftypefn

@deftypefn Verb string ejection_msg ()
@deftypefnx Verb string oejection_msg ()
@deftypefnx Verb string victim_ejection_msg ()
These three verbs return the messages used by the @code{@@eject} mechanism.
The code for the verb is shown below, as it illustrates how to deal with
multiple messages with a single verb:

@example
set_task_perms(caller_perms());
return $string_utils:pronoun_sub(this.(verb));
@end example

Note the permission setting at the start of the verb.  This is necessary
because the verb is owned by the Wizard, and hence would have permission
to read the ejection messages on any object.  By restricting the
permissions of the verb to those of the verb that called it, this verb
restricts who may access the ejection messages on objects.
@end deftypefn

@noindent
The following properties are defined for the @code{$room} class:

@defvr Property victim_ejection_msg
This is a string containing the message sent to objects that are
ejected from a room by the owner.  It is sent to the victim by the
room's @code{:@@eject} verb.
@end defvr

@defvr Property ejection_msg
This is a string containing the message sent to the owner when
they eject an object from the room.  It is printed by the room's
@code{:@@eject} verb.
@end defvr

@defvr Property oejection_msg
This is a string containing the message sent to everyone else in a room
when the owner ejects an object.  It is printed by the room's
@code{:@@eject} verb.
@end defvr

@defvr Property residents
This is a simple list of objects that have their homes in this room.  It
is examined by the @code{:accept} verb on the @code{$room} class as one of
the criteria used to determine whether an object is allowed to enter the
room or not.  The @code{@@sethome} verb could be enhanced to include
players as residents when their home is set to be a particular room.
@end defvr

@defvr Property free_entry
If this is set to a non-zero value, then the room is considered
@dfn{public} and any object is allowed to move in to the room.  Setting
the value to zero will stop objects that do not meet any of the other
acceptance criteria from entering.  Refer to the @code{$room:accept}
verb for further details on these criteria.
@end defvr

@defvr Property entrances
This is a simple list of the exits that lead @dfn{into} this room.  It
is manipulated by the @code{$room:add_entrance} and
@code{$room:remove_entrance}.
@end defvr

@defvr Property blessed_object
This contains the object number of the object that has been
@dfn{blessed} for entry into this room.
@end defvr

@defvr Property blessed_task
This contains the task ID of the task that requested an object be
@dfn{blessed} for entry into the room.
@end defvr

@defvr Property exits
This is a simple list of the exit objects that lead out of this room.
It is manipulated by the @code{$room:add_exit}, @code{$room:remove_exit}
and @code{$room:match_exit} verbs.
@end defvr

@defvr Property dark
If set to a non-zero value, then this property inhibits display of the
contents of a room when the @code{$room:look_self} verb is invoked.  It
can be used, for example, in rooms where a large number of objects are
likely to be located, that you do not wish to see (for instance, a
@dfn{limbo} type room, where sleeping players and lost objects reside.).
If the @code{dark} is set to zero, then the contents of a room are
displayed when @code{$room:look_self} is invoked.
@end defvr

@defvr Property ctype
This property determines the format of the room contents list, as
printed by the verb @code{$room:look_self}.  It can take a value between
`0' and `3'.  An example for each of the contents formats is given below.

@display
@table @code
@item 0: Traditional TinyMU* format.
Contents:
  Wizard
  a newspaper
  a fruitbat zapper
@item 1: Enhanced TinyMU* format.
Wizard is here.
You see a newspaper here.
You see a fruitbat zapper here.
@item 2: "All-in-one" format.
You see Wizard, a newspaper, and a fruitbat zapper here.
@item 3: The default, objects and player descriptive format.
You see a newspaper and a fruitbat zapper here.
Wizard is here.
@end table
@end display
@end defvr

@subsection The Thing Class

The @code{$thing} defines verbs and properties for objects that exist
in the virtual world.  This class includes everything that is not a
player, room or exit.  For example, the classes @code{$container} and
@code{$note} are descended from the @code{$thing} class.  The two basic
operations that can be performed on a thing are @dfn{picking it up} and
@dfn{putting it down}.  Two verbs are defined for the @code{$thing} class
to implement this idea.  Configurable messages are used, so that
someone using an object of this class can set the text printed when an
attempt is made to take an object.  No messages are available for the
case of dropping an object.

@deftypefn Verb none g*et ()
@deftypefnx Verb none t*ake ()
One or the other of these verbs is invoked when a player tries to take
possession of an object i.e., pick it up.  The code involved is fairly
straightforward.  It checks to see if the player already has the object,
and prints a suitable message if this is the case. If not, then the
@code{:moveto} verb on the object is invoked.  If this results in the
object moving into the player's inventory, then the @code{take_succeeded}
messages defined on the object are printed.  If the @code{:moveto}
failed, then the @code{take_failed} messages for the object are printed. 

This scheme allows you to add extra conditions to restrict whether a
player can take an object or not.  For example, you may place a notion
of @dfn{strength} onto a player, and add @dfn{weight} to objects.  If an
object is too heavy for a player to lift, then the object cannot be
taken by the player.  This sort of condition should be added to the
@code{:take} verb for the object.
@end deftypefn
 
@deftypefn Verb none d*rop ()
@deftypefnx Verb none th*row ()
One or the other of these verbs is invoked when a player tries to place
an object in the room s/he is currently located, i.e., when the player
tries to drop the object.  Again, the code is fairly straightforward.
If the object is not located on the player, then a suitable message is
sent to the player telling him/her to check his/her pockets.  If the
player does possess the object, and the current location @code{:accept}
verb indicates that the room will allow the object to be dropped, the
object @code{:moveto} verb is invoked to move the object from the
player's inventory to the contents list of the player's location.
Suitable messages are printed to inform the player that the action
succeeded, and to tell other people in the room that the object has just
been dropped.
@end deftypefn
 
@deftypefn Verb none moveto (obj @var{where})
This verb should be used to move an @code{$thing} object from one
location to another.  It checks to see that @var{where} is a valid
object, and that the lock on @var{wher} permits the object to enter.  If
this is the case, then the @code{$root_class:moveto} verb is invoked to
actually move the object, using @code{pass(@var{where})}.
@end deftypefn
 
@deftypefn Verb string take_failed_msg ()
@deftypefnx Verb string take_succeeded_msg ()
@deftypefnx Verb string otake_failed_msg ()
@deftypefnx Verb string otake_succeeded_msg ()
@deftypefnx Verb string drop_failed_msg ()
@deftypefnx Verb string drop_succeeded_msg ()
@deftypefnx Verb string odrop_failed_msg ()
@deftypefnx Verb string odrop_succeeded_msg ()
These eight verbs are used to access the message fields used by a
@code{$thing} object.  In each case, the value returned by the verb is a
a version of the corresponding @code{"_msg"} property of the object,
with standard pronoun substitutions performed.  This allows the messages
to be more flexible than simple constant text strings.  If extra
complexity were to be added to the messages, then these verbs should be
overridden.

The default values of these strings are shown below:

@display
@table @code
@item drop_failed_msg
"You can't seem to drop %t here."
@item drop_succeeded_msg
"You drop %t."
@item odrop_failed_msg
"tries to drop %t but fails!"
@item odrop_succeeded_msg
"drops %t."
@item otake_succeeded_msg
"picks up %t."
@item otake_failed_msg
""
@item take_succeeded_msg
"You take %t."
@item take_failed_msg
"You can't pick that up."
@end table
@end display
@end deftypefn

The following properties are defined for the @code{$thing} class. They
are the messages used by the @code{$thing:take} and @code{$thing:drop}
verbs in various situations.  All of these message can use standard
pronoun substitutions.

@defvr Property otake_succeeded_msg
This message is the text sent to other people in the thing's location
when the thing is taken by another object. The default value of this
string is @samp{picks up %t.}
@end defvr

@defvr Property otake_failed_msg
This message is the text sent to other people in the thing's location
when an attempt by another object to take the thing fails. The default
value of this string is @samp{}
@end defvr

@defvr Property take_succeeded_msg
When an object successfully takes a thing, this message is sent to
inform the object of success. The default value of this string is
@samp{You take %t.}
@end defvr

@defvr Property take_failed_msg
When an object unsuccessfully tries to take a thing, this message is
sent to tell the object that the attempt failed. The default value of
this string is @samp{You can't pick that up.}
@end defvr

@defvr Property odrop_succeeded_msg
This message is the text sent to other people in the thing's location
when the thing is dropped by another object. The default value of this
string is @samp{drops %t.}
@end defvr

@defvr Property odrop_failed_msg
This message is the text sent to other people in the thing's location
when an attempt by another object to drop the thing fails.  The default
value of this string is @samp{tries to drop %t but fails!}
@end defvr

@defvr Property drop_succeeded_msg
When an object successfully drops a thing, this message is sent to
inform the object of success.  The default value of this message is
@samp{You drop %t.}
@end defvr

@defvr Property drop_failed_msg
When an object unsuccessfully tries to drop a thing, this message is
sent to tell the object that the attempt failed.  The default value of
this string is @samp{You can't seem to drop %t here.}
@end defvr

@subsection The Exit Class

The @code{$exit} class is the other type of object used to construct the
fabric of the virtual world.  You can imagine an exit to be a flexible
tube connecting two @code{$room} objects.  Each @code{$exit} object goes
in one direction only.  It leads from a @dfn{source} object to a
@dfn{destination} object.  Note that it takes no virtual time to
traverse an exit.   When an object moves through an exit, it moves from
one room to another instantaneously.  

The verbs defined for the @code{$exit} class are fairly simple and
obvious.  Several messages are defined as properties on an exit.  These
are pronoun substituted and printed when the exit is invoked, under
various conditions.

@deftypefn Verb none invoke ()
This verb is used to trigger an exit.  In the @code{$room} class, when a
player elects to move through an exit, this verb is called to move the
player through the exit.  The code for this verb is very simple.  It
calls the exit's @code{:move} verb, with the @code{player} object as an
argument.

This is the verb to use for moving players through exits.  It does not
allow objects to be moved.  For that, a direct call to the
exit's @code{:move} verb is needed, with the object you wish to move
through the exit as an argument.
@end deftypefn

@deftypefn Verb none move (obj @var{thing})
This verb is used to move @var{thing} through the exit.  It provides a
general mechanism for moving any sort of object through the exit, not
necessarily just players.  The code for this verb performs a number of
actions.  First, the lock on the exit is checked to see if @var{thing}
is allowed to use the exit.  If this is not the case, the
@code{nogo_msg} and @code{onogo_msg} text is sent to @var{thing} and
everyone else in @var{thing}'s location, respectively.

If the object is allowed to use the exit, it is @dfn{blessed} for entry
to the destination room.  This is done to ensure that the object will be
accepted by the destination room.  It provides a way to stop objects
moving into a room by any means other than an exit leading into the
room.  By simply prohibiting all objects from entering the room, the
only way in is then to use an exit that leads into that room.

If the object is accepted by the room, determined using the
@code{$room:accept} verb, then the @code{leave} messages are printed to
@var{thing} and the other people in the room.  Then
@var{thing}@code{:moveto} is invoked to move the object from the current
room to the destination of the exit.  Once this has been done, the
@code{arrive} messages for the exit are printed out to @var{thing} and
the destination room's occupants.
@end deftypefn

@deftypefn Verb none recycle ()
This verb is defined to allow an exit to be tidily removed from the
database.  The exit is removed from the @code{entrance} and @code{exit}
lists of the destination and source rooms respectively, if the caller of
this verb has permission to do so.  This is done using the
@code{$room:remove@{entrance|exit@}} verbs.
@end deftypefn

@deftypefn Verb none leave_msg () 
@deftypefnx Verb none oleave_msg () 
@deftypefnx Verb none arrive_msg () 
@deftypefnx Verb none oarrive_msg () 
@deftypefnx Verb none nogo_msg () 
@deftypefnx Verb none onogo_msg
These verbs return a pronoun substituted version of the corresponding
properties stored on the exit object.  They are used by
@code{$exit:move}.
@end deftypefn

The following properties are defined for the @code{$exit} class.  Most
of them are messages used when the exit is invoked.  

@defvr Property source
This is the object that the exit leads out of.  If the exit has been
created using the correct verbs, the exit object should be in the
@code{exits} list of the @code{source} room object.
@end defvr

@defvr Property dest
This is the object that the exit leads to.  If the exit has been created
using the correct verbs, the exit object should be in the @code{entrances}
list of the @code{dest} room object.
@end defvr

@defvr Property nogo_msg
This is the message printed to an object if it is unable to move through
the exit.
@end defvr

@defvr Property onogo_msg
This is the message printed to everyone in an object's location if it is
unable to move through the exit.
@end defvr

@defvr Property arrive_msg
This is the message printed to an object using an exit when it arrives
in the destination room.
@end defvr

@defvr Property oarrive_msg
This is the message printed in the destination room of the exit when
something is moved through it.
@end defvr

@defvr Property oleave_msg
This is the message printed in the exit's source room when an object
moves through the exit.
@end defvr

@defvr Property leave_msg
This is the message printed to an object using the exit as it leaves the
source room.
@end defvr

@subsection The Player Class

The player class is the one of the basic classes of the virtual world.
A player object is the same as any other object, except that has it's
@code{player} bit set.  This allows the server to connect a user to that
object.  A number of player commands are defined as verbs of the
@code{$player} class, as well as other useful functions.

@deftypefn Verb none g*et ()
@deftypefnx Verb none take ()
This verb is called in the situation when another object tries to
@dfn{get} or @dfn{take} a player.  Given that this is a fairly
nonsensical thing to do, it is not allowed.  Suitable messages are sent
to the object that invoked the action, and the player object.
@end deftypefn

@deftypefn Verb none i*nventory ()
This verb is used to tell a player what s/he has in his/her pockets.
The code for the verb provides the best documentation, so it is printed
below.  Note the use of the @code{thing:title} verb to get the name of
an object.

@example
if (length(player.contents))
  player:tell("You are carrying:");
  for thing in (player.contents)
    player:tell(thing:title());
  endfor
else
  player:tell("You are empty-handed.");
endif
@end example
@end deftypefn

@deftypefn Verb none wh*isper ()
This verb is used to send secret messages between two players, as if
they were whispering to each other.  The way this works is slightly the
reverse of what might be expected, because the @code{:whisper} verb on
the person being whispered to is the one that is invoked.   The message,
referred to by the @code{dobjstr}, is printed to the recipient, with
suitable text surrounding it to indicate that is it a whisper.
@end deftypefn

@deftypefn Verb none look_self ()
This verb overrides the @code{$root_class} definition to provide an
indication to other players of whether this player is currently active
or not.  It uses @code{pass()} to allow the parent class to print a
description, and then looks at the @code{connected_players()} list to
determine if this player is currently connected.  If not, then the text

@example
He is sleeping
@end example

@noindent
is printed.  If the player is connected, and has been
idle for less than 60 seconds, then the string 

@example
He is awake and looks alert
@end example

@noindent
is printed.  If the player is connected, but has been inactive
for more than 60 seconds, the string 

@example
He is awake, but has been staring off into space for @strong{X}
@end example

@noindent 
is printed, where @code{X} is an indication of the time the player has
been inactive.  The gender pronoun inserted is taken from the pronoun
list for the player.  This means it can vary with the gender of the
player object. 

If the player is carrying any objects, a simple list of these is
printed.
@end deftypefn

@deftypefn Verb none @@gag (@var{args})
The concept of gagging is fairly simple to understand.  If there is a
player or object you do not wish to see any output from, then you can
place the player or object into your @dfn{gag list}.  If any output is
sent to you from that object, using it's @code{:tell} verb, then it is
ignored, and not printed on your terminal screen.

Two gaglists are maintained: one for players, in the property
@code{gaglist} and one for objects, in the property
@code{object_gaglist}.

Three verbs are used to maintain and observe the list of objects that
are in the gag lists.  The @code{@@gag} verb is used as a player command
to add objects to the gag lists.  The code for this is fairly
straightforward, and is included below:

@example
if (player != this)
  player:tell("Permission denied.");
  return;
endif
victims = $string_utils:match_player(args);
if (!victims)
  player:tell("Usage:  @@gag <player or object> 
                    [<player or object>...]");
  return;
endif
gagplayers = gagobjs = @{@};
for i in [1..length(args)]
  if (valid(victims[i]))
    gagplayers = @{victims[i], @@gagplayers@};
  elseif (valid(o = player.location:match(args[i])))
    gagobjs = @{o, @@gagobjs@};
  elseif (tonum(o = toobj(args[i])) && valid(o))
    gagobjs = @{o, @@gagobjs@};
  else
    player:tell("Could not find ", args[i], " as either a player or an object.");
  endif
endfor
changed = 0;
for p in (gagplayers)
  if (p in player.gaglist)
    player:tell("You are already gagging ", p.name, ".");
  else
    changed = 1;
    player.gaglist = setadd(this.gaglist, p);
  endif
endfor
for o in (gagobjs)
  if (o in player.object_gaglist)
    player:tell("You are already gagging ", o.name, ".");
  else
    changed = 1;
    player.object_gaglist = setadd(this.object_gaglist, o);
  endif
endfor
if (changed)
  fork (0)
    this:("@@listgag")();
  endfork
endif
@end example

Note that you can only manipulate your own gag list.  Other objects
cannot change your gag list.  Another interesting point is the call to
@code{@@listgag}, after the new objects have been added to the gag
list, to print the current gag list.

The code first tries to match the argument list against the players in
the database, using @code{$string_utils:match_player()}.  Then, for each
argument given, if a match was not found using that method, a match for
an object in the room is tried, using the utility routine
@code{$string_utils:match_object()}.  If this fails, the argument is
rejected.

This results in a list of objects to be added to the player's gag lists.
Any objects already in the player's gag lists are removed from the
@dfn{to do} list.  If this yields an empty @dfn{to do} list, the command
is aborted.  Any objects that are not already in the gag list are added
to it.

Finally, @code{this:@@listgag} is called to print the list, if it has
changed. 
@end deftypefn

@deftypefn Verb none @@listgag ()
This verb is used as a player command to list the objects in the
player's gag lists.  If the gag lists are not empty, a list of the names
of the players in the @code{gaglist} property on the player, and the
objects in the @code{object_gaglist} property are produced.

The verb uses a test based on the @code{callers()} primitive, to
determine if it is being called by another verb, or invoked by a player
as a command.  If @code{callers()} returns a null list (and hence is not
@code{TRUE}, then the verb is being invoked as a player command.  This
affects the text printed by the verb.

In addition, the verb checks through the gag lists of all the player's
in the database, to see if the player who invoked the command is listed
in anyone else's gag list.  If this is the case, a list of the people
doing the gagging is printed.
@end deftypefn

@deftypefn Verb none @@ungag (@var{args})
This verb is used as a player command to remove an object from one
of the player's gag lists, if it is a member.  The @code{dobjstr} is
used as the name of the thing to remove from the gag list.

If this name is @samp{everyone} then the player gag and object
gag lists are reset to the empty list.  Otherwise, if a valid direct
object has been referred to, by checking @code{dobj}, that is used as
the object to gag.  Otherwise, an attempt is made to match the
@code{dobjstr} with something in the player gag list.  If no match is
found, it is retried with the object gag list.  If this fails, the
command is aborted with an error message.

If a valid match is found, it is removed from the relevant list, and the
player informed. @code{@@listgag} is used to print the list after the
operation has been completed.
@end deftypefn

@deftypefn Verb none news ()
This is a very simple verb used as a player command to print out the
current MOO news.  It makes a simple call to the verb @code{$news:read}
to actually perform the reading task.
@end deftypefn

@deftypefn Verb none @@gripe (@var{args})
A @dfn{gripe} is a player complaint or observation that is sent, using
MOO mail, to all the administrators in the game.  It is intended to
provide a way to report problems with the MOO in a high-priority way
that will attract the attention of the people who can do something about
it.  A good example of the use of a gripe is to complain about a bug in
one of the core classes, or maybe even a request for something to be
added. 

The implementation of the gripe concept involves a property on the
@dfn{System Object} called @code{$gripe_recipients}.  This is a list of
all the players who will be mailed the @code{@@gripe} message.  When a
player types in @code{@@gripe} they are taken to the mail room to enter
their message.  Any text entered on the line with the @code{@@gripe}
command is taken to be the subject of the gripe message.  When the
message is finished and sent, it is received by all the people on the
@code{$gripe_recipients} list.
@end deftypefn

@deftypefn Verb none gi*ve ()
@deftypefnx Verb none ha*nd ()
This verb is a player command used to exchange objects between players.
It performs a @code{:moveto} on the direct object to the inventory of
the indirect object.  If, after the move, the object is still in the
possession of the donor, then it is obvious that the recipient has
rejected the gift.  If this is the case, a suitable message is printed
to the doner.
@end deftypefn

@deftypefn Verb none ? help info*rmation ()
This verb is a player command used to activate the help system.  It is
described more fully in the section on the help system.
@end deftypefn

@deftypefn Verb none @@password ()
This verb is a player command used to change a player's password.  A
player's password is stored in a property on the player called,
surprisingly enough,  @code{password}.  The @code{crypt()} primitive is
used to store the password in encrypted form, using the standard UN*X
encryption algorithm.  Note that you need to know your old password in
order to change it, unless a password has not been previously set for
this player.
@end deftypefn

@deftypefn Verb none @@gender (string @var{gender})
This verb is used to set the gender of a player object.  Without any
arguments, it prints the player's gender, currently set pronouns and the
available genders stored on @code{$gender_utils.genders}.

If a gender is given as the argument, @var{gender}, then the
@code{$gender_utils:set} verb is called to actually change the player's
gender pronouns.  If this verb does not return an error, then the gender
of the player is set to the full gender name which is returned.
@code{$gender_utils:set} takes care of setting the correct pronouns.

If an error is returned when trying to set the player's gender, this
could indicate that permission to change the pronouns was denied, or
some other problem existed.  If a value of @code{E_NONE} is returned by
@code{$gender_utils:set} then the gender of the player is set, but the
pronouns are left unchanged.

The gender of a player is used in the @code{string_utils:pronoun_sub}
verb to insert the appropriate pronouns in places where @samp{%}
substitutions have been used.  When the gender of a player is changed,
it results in a set of 8 properties being assigned on the player, one
for every type of possible pronoun substitution.  A further property,
containing the gender of the player, is also set, for example, to either
"male", "female", or "neuter", depending on the argument given to the
@code{@@gender} command.
@end deftypefn

@deftypefn Verb none page (list @var{args})
This verb is a player command used to send messages between players who
are not physically located in the same room in the virtual world.  You
can imagine a @dfn{page} to be a worldwide form of whispering.  Without an
argument, a message like

@example
You sense that blip is looking for you in The Venue Hallway.
@end example

@noindent
is sent to the recipient of the page.  If an argument is given, it is
treated as a message to send to the other player.  This results in the
recipient getting a message like

@example
You sense that blip is looking for you in Hallway.
He pages, "Hello - are you busy ?"
@end example

Paging is used primarily to attract the attention of a player, or to
pass short messages between players in different locations.  It is not
intended to be used for conversation.

If a player name has been given as an argument, the @code{:page} verb
first tries to match the first argument with a player name, using
@code{$string_utils:match_player}.  If a match is found, then there are
two possibilities.  Firstly, if the player is not connected, a pronoun
substituted version of the string returned by that player's
@code{:page_absent_msg} verb is printed to the sender, and the verb is
aborted.

Otherwise, if the recipient is connected, we send him/her the string
returned by the sender's @code{:page_origin_msg}.  We then check to see
if, optonally, @samp{with} followed by a message is part of the argument
list for the verb.  If so, then the message is extracted from the
argument list and sent to the recipient, suitably pronoun substituted. 
The string returned by the recipient's @code{:page_echo_msg} verb is
printed to the sending player.

An interesting piece of coding is used to stop the line containing the
message from duplicating the sender's name if it has already been sent
as part of the @code{:page_origin_msg}.  For example, if blip page's
Ezeke, Ezeke might see the following:

@example
You sense that blip is looking for you in The Venue Hallway
He pages, "Hello"
@end example

@noindent
which would be better than something like

@example
You sense that blip is looking for you in The Venue Hallway
blip pages, "Hello"
@end example

@noindent
The code in question is shown below:

@example
who:tell($string_utils:index_delimited(pagemsg, player.name) ? 
           player.psc | player.name, " pages, \"", msg, "\"");
@end example

@noindent
Here, the @code{$string_utils:index_delimited()} verb is used to check
if the player's name occurs in the string we sent to the recipient as
@code{pagemsg}.  If it does, then we print the player's subjective
pronoun, capitalised.  If it doesn't, we print the player's name.
@end deftypefn

@deftypefn Verb none @@rename ()
This verb is a player command used to change the name and aliases of an
object or verb.  It first tries to parse the supplied direct object as a
verb reference.  If this succeeds, then it tries to match the object,
and then the verb name.  If both are found, the indirect object string
is used to set verb name.

If the direct object string cannot be parsed as a verb, then a match is
attempted using the string as an object name.  If this succeeds, then
@code{$building_utils:set_names()} is used to set the name and aliases
of the matched object.

Any permission errors, ambiguous object specifications or syntax errors
are flagged appropriately.
@end deftypefn

@deftypefn Verb num accept (obj @var{thing})
This verb is used to determine if a player will allow @var{thing} to be
moved into his/her inventory.  The verb defined for the @code{$player}
class allows anything that is not a player to be moved into the player's
possession.  You could override this verb to restrict the sorts of
things you would want other people to be able to place on your person.
@end deftypefn

@deftypefn Verb none tell ()
This verb should be used to send a message to a player.  The
@code{$player:tell} filters messages in two different ways, as show
below. Remember that the @var{player} referred to in the code is the
player sending the message.  @var{this} refers to the player receiving
the message.

@example
if (!this:gag_p())
  if (this.paranoid == 2)
    z = this:whodunnit(listappend(callers(), @{player, "", player@}), 
               @{this@}, @{@})[3];
    pass("(", z.name, " ", z, ") ", @@args);
  else
    pass(@@args);
    if (this.paranoid == 1)
      this.responsible = listappend(this.responsible, 
          @{listappend(callers(), @{player, "<cmd-line>", 
	                            player@}), args@});
      while (length(this.responsible) > this.lines)
        this.responsible = listdelete(this.responsible, 1);
      endwhile
    else
      this.responsible = @{@};
    endif
  endif
endif
@end example

@noindent
The verb @code{$player:gag_p} returns true if the player sending the
message is in the recipient's @dfn{gag list}.  For this verb, the output
from any gagged player is ignored, and not printed to the recipient's
terminal.

If the @dfn{paranoid level} of the recipient is @samp{2}, this means
that they wish to see who has sent them a message.  The
@code{$player:whodunnit} verb returns the object reference of the player
that sent the message.  This is prepended to the message text, which is
then printed to the player.

If the @dfn{paranoid level} of the recipient is @samp{1}, then the
message and it's originator are stored in the property list
@code{responsible} on the player.  The list is kept to
@var{player.lines} length, at most.  This option is used for later
processing by the @code{@@check} command.
@end deftypefn

@deftypefn Verb list whodunnit (list @var{callers}, list @var{trust}, list @var{mistrust})
This verb runs through the list of @var{callers} until it finds an
object reference that is not a wizard, is not in the list @var{trust},
or is in the list @var{mistrust}.  The verb is used by
@code{$player:tell} to locate the originator of a message.  It returns a
list of three elements, in the same format as that returned by the
@code{callers()} primitive:

@example
@{@var{this}, @var{verb-name}, @var{programmer}@}
@end example

@noindent
where @var{this} is the initial value of the variable @code{this} in
that verb, @var{verb-name} is the name used to invoke the chosen verb,
and @var{programmer} is the player with whose permissions that verb is
running.
@end deftypefn

@deftypefn Verb num gag_p ()
This verb returns @samp{TRUE} if the current value of the @code{player}
variable is in the gag list of the object indicated by the variable
@code{this}, or if a non-player object mentioned in the gag list if the
first elements of the verbs @code{callers()} list.
@end deftypefn

@deftypefn Verb none home ()
This verb is normally invoked by the player as a command.  The
@dfn{home} of a player is the room where s/he goes to when they
disconnect.  Unlike some flavours of MUD, MOO does not cause you
to lose all your possessions if you go home.

The @code{:home} verb performs a simple sequence.  It first checks
whether the player is already at home, and tells him/her so if this is
the case.  Secondly, a check is made that the player's home (stored in
the @code{home} property on the player, is a valid object.  If this is
not the case, the verb sets the home to the default,
@code{$player_start}, and stops with a suitable message.

Having decided that the player has a valid home s/he is not already in,
the verb uses @code{$player:moveto} to send the player to the home
location.  If this doesn't work - checked by comparing the player's home
with the player's location after the move - then for some reason the
player's home location has not allowed him/her to enter.  A suitable
message is printed, and no further action is taken.
@end deftypefn

@deftypefn Verb none @@sethome ()
This verb is a player command used to set the player's @dfn{home} to be
the his/her current location.  You can only set your home to a room if
the room will accept you, determined by checking the room's
@code{:accept} verb..  This allows builders to restrict which rooms may
be used by players as their homes.  If the room does not allow the
player to set it as his/her home, a suitable message is printed to
inform the user of this fact.  Otherwise, the player's @code{home}
property is set to the player's current location.
@end deftypefn

@deftypefn Verb none confunc ()
This verb is called when the player connects to the LambdaMOO server.
It can be used to perform actions that should be done every time the
player logs in to the MUD.  This is much the same idea as having a
@code{~/.cshrc} or @code{~/.kshrc} file that is activated when you log
into a UN*X account. The verb defined for the player class is listed
below:

@example
$news:check(this);
for x in (this.messages)
  if (x[1] > this.current_message)
    this:tell("You have new mail.  Type 'help mail' for 
                                          info on reading it.");
    return;
  endif
endfor
@end example

This performs a couple of actions.  First it calls @code{$news:check} to
see whether the news has been updated since this player last looked at
it.  Then it checks through the MOO Mail list on the player to see if any
mail has arrived since they were last connected.

You could place a variety of actions into this verb.  For example, you
may wish to tell your friends when you log in, by sending a suitable
message to them if they are connected.  Similarly, you may wish to
produce a special message in the room you are in when you connect.
@end deftypefn

@deftypefn Verb none disfunc ()
This verb is invoked when the player disconnects from the LambdaMOO
server.  The verb defined for the @code{$player} class does nothing.
You might choose to override this verb to print a special message when
you log out, or perhaps to retrieve some of your possessions.
@end deftypefn

@deftypefn Verb none whereis (@var{args})
@deftypefnx Verb none @@whereis (@var{args})
This verb is a player command used to locate a player in the virtual
world.  The code, shown below, allows any player to locate any other
player.  If no argument is given, a list of the locations of all the
currently connected players is printed.

@example
if (!args)
  them = connected_players();
else
  who = $command_utils:player_match_result(
                     $string_utils:match_player(args), args);
  if (length(who) <= 1)
    if (!who[1])
      player:tell("Where is who?");
    endif
    return;
  elseif (who[1])
    player:tell("");
  endif
  them = listdelete(who, 1);
endif
lmax = rmax = 0;
for p in (them)
  player:tell(p:whereis_location_msg());
endfor
@end example

@noindent
If an argument is given, the verb attempts to match with one or more
player names.  If no valid matches are found, a suitable error message
is printed by invoking the verb
@code{$command_utils:player_match_result}.  That verb returns a list.
The first element indicates whether any of the elements of the argument
list didn't match.  The rest of the list contains the objects references
that did match.

The verb runs through the list of object references, and reports the
string returned by each player's @code{whereis_location_msg} verb.
@end deftypefn

@deftypefn Verb none @@mail ()
@deftypefnx Verb none @@rmm*ail ()
@deftypefnx Verb none @@send ()
@deftypefnx Verb none @@read ()
@deftypefnx Verb none @@answer ()
@deftypefnx Verb none @@reply ()
@deftypefnx Verb none @@renumber ()
@deftypefnx Verb none receive_message ()
@deftypefnx Verb none fix_current_message ()
@deftypefnx Verb none @@next ()
@deftypefnx Verb none @@prev ()
These functions are player commands used to access the MOO Mail system.
They are fully described in the section on the MOO mail system.
@end deftypefn

@deftypefn Verb none @@quota ()
This verb is a player command used to print a player's current
building quota.  This is a numerical value of the number of objects that
the player may create without recycling anything.  Quotas are used to
limit the number of objects that can be created, in principle to allow
the game administrators to quality control the things that are placed in
the database.

With no argument, the player's quota is displayed, taken from the
property @code{ownership quota}.  If an argument is given in the
@code{dobjst}, it is taken as a player name, and matched to find a
player object reference.  If one is found, and the user is a wizard,
then the value of that player's @code{ownership_quota} is returned.
Otherwise, a @samp{permission denied} message is returned.
@end deftypefn

@deftypefn Verb none @@realm (@var{args})
This is a player command used to examine the object hierarchy.  The
arguments can specify the players whose objects are to be shown, the root
object number to start from, and a list of objects to miss from the
tree search.

Firstly, the verb parses the arguments, to determine the root to start
from, the players whose objects we are intersted in, and any objects
that are to be ignored.  Any ancestors of the root are printed by a
short loop, with the owner appended in square brackets. The verb
@code{this:realm2} is called to produce the hierarchical list of
objects to printed.  A summary of the number of objects in the list, and
how many are owned by the player, is printed at the end.
@end deftypefn

@deftypefn Verb list realm2 (obj @var{root}, list @var{owners}, string @var{space}, list @var{missing})
This verb puts toegther a number of lines of text indicating the object
hierarchy from the @var{root} object downwards.  Only objects owned by
people in the @var{owners} list are included.  Objects in the
@var{missing} list are excluded.    The verb is called recursively to
evaluate the descendants of each node in the tree of objects.  The
string @var{space} is the visual indentation factor used to represent
different levels in the hierarchy.
@end deftypefn

@deftypefn Verb none @@count ()
This verb is a player command used to print the number of objects owned
by a particular player.  If no player name is given in the
@code{dobjstr}, then the number of objects owned by the player invoking
the verb is printed.  In both cases, the verb @code{this:count_2} is
called to do the actual counting and displaying.
@end deftypefn

@deftypefn Verb none count_2 (num @var{count}, num @var{start})
This verb is called to count the number of objects owned by the player
indicated by @code{dobj}.  The verb first checks the current remaining
time available for it to execute in.  If it is in danger of running out
of time, it forks another @code{:count_2} verb to carry on from where it
left off.  This enables the verb to count lots of objects in a large
database.

Foe each object, if it is valid, and the owner is the same as
@code{dobj}, then the count is incremented.  This is performed for every
object in the database, from @var{start} to the last item.

When all the objects in the database have been looked at, the total is
printed.
@end deftypefn

@deftypefn Verb num set_name ()
This verb is used to set the name of the player object.  It overrides
the verb @code{$root_class:set_name} to provide some extra checking
needed for player objects.  This checking basically stops you changing
your name to be the same as another player.  Note also that spaces are
not allowed in player names.  If the extra checks are passed, the parent
@code{set_name} verb is called to actually set the name.
@end deftypefn

@deftypefn Verb none @@memory ()
This is a player command used to return memory usage statistics for the
LambdaMOO server.  It uses the @code{memory_usage()} primitive to gather
usage information, which is then printed in a nicely formatted fashion.
@end deftypefn

@deftypefn Verb none announce (@var{args})
@deftypefnx Verb none announce_all_but (@var{args})
This verb is used to call the @code{:announce} and
@code{:announce_all_but} verbs in the player's location, if those verbs
are defined, and the player is in a valid location.  It is used by noisy
objects in player's inventories that wish to broadcast messages to both
the player, and others in the surrounding room.
@end deftypefn

@deftypefn Verb none @@notedit (@var{args})
This is a simple verb used as a player command to invoke the note editor
on the argument.
@end deftypefn

@deftypefn Verb none @@who (list @var{names})
This verb is a player command used to determine who is currently
connected to the MOO.  If @var{names} is given, it is a list of player
names to display in the @dfn{who list}.  In both cases, the list is
sorted, using @code{$list_utils:sort_alist} and displayed.  Player names,
connection times, idle times and locations are displayed.  Player name
is determined by getting the value of the @code{name} property on the
player.  Connection time is determined by using the @code{connected
seconds()} primitive.  Idle time is determined using the
@code{idle_seconds()} primitive.  The location is determined by the
return value of a player's @code{:who_location_msg} verb.

A summary of player activity is attached to the end of the list.
@end deftypefn

@deftypefn Verb none @@typo (@var{args})
@deftypefnx Verb none @@bug (@var{args})
@deftypefnx Verb none @@suggest*ion (@var{args})
@deftypefnx Verb none @@idea (@var{args})
These commands are used register a typo/bug/suggestion/idea with the
person who owns the room the player is currently in.  If @var{args} is
given, this is used as the text of the message, and is delivered
straightaway to the room owner.

If no argument is given, the player is taken to the mail room to compose
a full message.  However, if the room the player is in does not have it's
@code{free_entry} property set, then the verb doesn't move the player to
the mail room, as s/he may not be able to reenter the current room after
the message has been completed.  Similarly, if the @code{$generic
editor} is a parent of the current room, then the move is not performed.
Generally speaking is is not a good idea to be taken to the mail room
from within another editor.
@end deftypefn

@deftypefn Verb none @@quit ()
This verb is a player command used to exit in an orderly fashion from
the MOO server.  It simply calls the @code{boot_player} primitive to
disconnect the player.
@end deftypefn

@deftypefn Verb none @@audit ()
This verb is a player command used to print the objects owned by this
or another player.  If a direct object is given, this is taken as a
player name to audit, otherwise the current value of @code{player} is
used.  In both cases, the @code{this:audit_2} verb is called to do the
actual counting and displaying of objects.
@end deftypefn

@deftypefn Verb none audit_2 (num @var{count}, num @var{start})
This verb is called by the @code{@@audit} command to print the objects
owned by player given in @code{dobj}.   In a similar way to
@code{@@count}, the verb first checks how much time it has left.  If it
might run out, then it forks another occurrence of itself to carry on
auditing where it left off.  

A loop is entered, running from @var{start} to the last item in the
database.   Each object in the database is looked at.  If it is valid,
and the owner matches the @code{dobj}, then the object name and
reference number are printed, and the count is incremented.

When all the objects in the database have been covered, the total count
is printed out.
@end deftypefn

@deftypefn Verb none @@eject ()
This verb is a player command used to remove objects from rooms or the
player's inventory.  The indirect object is used to specify what the
direct object is to be ejected from.  The special cases of @samp{me} and
@samp{here} are caught and handled.  Similarly, the case where the
direct object is @samp{me} is also handled.

If neither of the special cases match, the direct and indirect object
are matched on, to give an object reference to use.  Suitable error
messages are printed if a match is not found.  If matches are found,
then a sequence of message printing is started.  The indirect object's
@code{:victim_ejection_msg} verb is invoked, and the returned result
printed to the victim.  The string returned by the indirect object's
@code{:ejection_msg} is printed to the player doing the ejecting.  The
result returned by the indirect object's @code{oejection_msg} verb is
printed to everyone else in the room.

Finally, the indirect object's @code{:eject} verb is called to remove
the victim.
@end deftypefn

@deftypefn Verb none QUIT ()
This player command used to be the way to disconnect from the MOO.  It
has been replaced with the @samp{@@quit} command.  Some rooms, for
example editors, define the @samp{QUIT} command. If the room the player
is in has a @code{:QUIT} verb, it is called.  Otherwise, the verb prints
a message telling the player to use the @samp{@@quit} command.
@end deftypefn

@deftypefn Verb none @@unlock ()
This verb is a player command used to unlock an object.  The direct
object string, @code{dobjstr} is matched to try and find an object to
unlock.  If a match is found, the @code{key} property is reset to
@samp{0}.  Any errors are reported to the invoking player.
@end deftypefn

@deftypefn Verb none @@lock ()
This verb is a player command used to lock an object with a specified
key.  It first matches the direct object, @code{dobj} to get an object
reference number.  If that succeeds, the
@code{$lock_utils:parse_keyexp()} verb is called to parse the key
expression given for thelock.  If that fails, a suitable error message
is printed.  Othwerwise, the @code{key} property of the object being
locked is set to the returned value from the parsing verb.  Again, any
errors are reported to the invoking player.
@end deftypefn

@deftypefn Verb none @@version ()
This is a player command used to print the current server version
number, using the @code{server_version()} primitive.
@end deftypefn

@deftypefn Verb none @@mess*ages ()
This is a player command used to list the possible message properties
(those that end in @samp{_msg}) on the @code{dobjstr} supplied.   The
names of the messages, along with their current values, are displayed.
@end deftypefn

@deftypefn Verb none @@sw*eep ()
This is a player command used to list the objects that are capable of
receiving any messages sent out from the player in the current room.  It
gathers a list of the objects in the current room, from the
@code{contents} property of the player's location.  In any element in
the list is a connected player, the message

@example
blip (#42) is listening.
@end example

@noindent
is printed, for example.

If an element has a @code{sweep_msg} verb defined, the returned string
from this verb is printed, prepended by the object's name.

If an element has a @code{tell} verb defined, and the owner is not the
invoking player or a wizard, then this object is a potential snooper,
and is reported by a phrase such as:

@example
The Fruitbat (#999) has been taught to listen by blip (#42).
@end example

@noindent
The verbs @samp{announce}, @samp{announce_all}, @samp{announce_all_but},
@samp{say}, @samp{emote}, @samp{huh}, @samp{huh2} and @samp{whisper} are
checked to see if the current room has a definition not owned by the
invoking player or a wizard.  If any of these are found, a message such
as:

@example
The Venue Hallway (#1234) may have been bugged by blip.
@end example

@noindent
if the player's location was the Venue hallway.

If no potential bugs are found, the the message @samp{Communications are
secure.} is printed, and the player can breath easily (ish).
@end deftypefn

@deftypefn Verb none @@che*ck (list @var{args})
This is a player command used to check the origin of the last few
messages received by the player. The @var{args} list can contain the
number of lines to print as the first element, followed by a list of
player names.  Each player name in the list is a person to be
@dfn{trusted}, unless the name is prefixed by an exclamation point,
@samp{!}, in which case the person is not to be trusted.

The verb starts by building up a list of trusted and mistrusted
individuals based on the names given on the command line.  Then it runs
through last @var{n} messages in the player's @code{responsible}
property list, checking the origin of the messages using the
@code{this:whodunnit} verb with the @var{trust} and @var{mistrust}
lists.

Any dubious messages found are printed, along with details of who sent
them.
@end deftypefn

@deftypefn Verb none @@move ()
This is a player command used to move objects from one location to
another.  The direct and indirect object strings are used to match an
object and location to move to.   The @code{:moveto} verb on the
@code{dobj} is invoked to move it to the @code{iobj} location.  If the
location changes, and the object is a player, then the message

@example
blip disappears suddenly for parts unknown.
@end example

@noindent
is displayed in the player's location before the move took place.
Similarly, at the new location, the message

@example
blip materializes out of thin air.
@end example

@noindent
is printed to the objects in the destination room.  No messages are
printed if an object is moved.  If a permission problem is found, it is
reported to the player who typed the command.
@end deftypefn

@deftypefn Verb none @@par*anoid ()
This verb is used to set the player's @dfn{paranoid level}, as stored in
the @code{.paranoid} property.  Three different levels are available :

@itemize @bullet
@item 
0.  The normal case, where no paranoia is applied to any messages
sent to the player.
@item 
1.  In this case, the anti-spoofer is enabled, and the value of
the @code{lines} property on the player is set to 20.  This determines
how many messages are stored on the player, for checking with the
@samp{@@check} command.
@item
2.  In this case, every message sent to the player is prefixed with the
name and object number of the sender.  This is the @dfn{immediate} mode
of the anti-spoofer mechanism.
@end itemize
@end deftypefn

@deftypefn Verb none @@s*how ()
This is a player command used to examine other objects in detail.  It
returns details of an object's owner, location, parent, and all the
verbs and properties defined for the object, along with their values, if
permissions allow.
@end deftypefn

@deftypefn Verb none @@desc*ribe ()
This is a player command used to set the description of an object.  It
takes the @code{dobjstr} and tries to match it with an object.  If a
match is found, then the object's @code{:describe} verb is invoked, with
the @code{dobjstr} as an argument.
@end deftypefn

@deftypefn Verb none @@create (@var{args})
This verb is a player command used to create an instance of an object or
class.   It parses the arguments to extract the parent object we wish to
create an instance of, along with the name we wish to give to the
created object.  The @code{create()} primitive is called, with the
derived @var{parent} as an argument.  The resulting object is moved to
the player's inventory, using the @code{move()} primitive, and it's
names and aliases set using @code{$building_utils:set_names}.  
@end deftypefn

@deftypefn Verb none @@recycle ()
This is a player command used to recycle an object.  This simply matches
the @code{dobjstr} with an object, and calls the @code{recycle()}
primitive to recycle the object. The returned value, in the case of an
error, is printed to the player. Otherwise, a suitable success message
is sent.
@end deftypefn

@deftypefn Verb none @@dig ()
This is a player command used to create a room or exit, (that is,
instances of the class @code{$room} or @samp{$exit}.  The verb parses
the arguments to determine the type and number of objects that are to be
created.  It uses the @code{create()} primitive, with @code{$room} as a
parent to create a room.   Note that you can only use the @code{@@dig}
command to dig an exit from within a room.  The
@code{building_utils:make_exit} verb is called to dig an exit.
@end deftypefn

@deftypefn Verb none @@cl*asses ()
This is a player command used to list the publicly available classes
in the database.  The public classes are divided into different
sections, as defined by the property @code{$class_registry}.  This
contains a list of entries, in the following form:

@example
@{ @{@var{name}, @var{description}, @var{members}@}, @dots{} @}
@end example

@noindent
where @var{name} is the name of the superclass of objects,
@var{description} is a short, one line description of the superclass,
and @var{members} is a list of object references that are in the
superclass.

If no argument is given to the @samp{@@classes} command, it runs through
the entries in the @code{$class_registry} and prints out the name and
description.

If an argument is given, it is taken as one or more names of an entries in the
@code{$class_registry}.    The names of the @var{members} of the
requested classes are printed, in this case, using @code{this:classes_2}.
@end deftypefn

@deftypefn Verb none classes_2 (obj @var{root}, @var{indent}, list @var{members}, list @var{printed})
This verb is called by @samp{@@classes} to print the members of the
classes given in @var{members}.  It is called recursively to list all
the children of every class in @var{members}.  If @var{root} is in the
list of @var{members} then it is printed as the class root name.
Otherwise, it is printed as a member of the class.  For every child of
the @var{root}, if it is in the set @var{printed}, @code{this:classes_2}
is called, to print any descendants.
@end deftypefn

@deftypefn Verb str who_location_msg ()
@deftypefnx Verb str whereis_location_msg ()
@deftypefnx Verb str page_origin_msg ()
@deftypefnx Verb str page_echo_msg ()
@deftypefnx Verb str page_absent_msg ()
These verbs return the value of the corresponding property on the player
after pronoun substitution.  They are provided to allow the player to
override the verbs for more distinctive and complex messages.
@end deftypefn

The following properties are defined for the @code{$player} class.

@defvr Property current_message
This property contains an integer index into the list of MOO Mail
messages currently stored in the @code{messages} property.  It is used
by the mail handler to determine which message the player is currently
looking at.
@end defvr

@defvr Property messages
This property contains a list of mail messages.  Each mail message is a
list in the following format:

@example
@{@var{num}, @{@var{line-1}, @var{line-2}, @dots{}, @var{line-n}@}@}
@end example

@var{num} gives the message number used in the various MOO mail
commands.  The list of strings contains the text of the message, one
line per string.
@end defvr

@defvr Property last_connect_time
This property is an integer, holding the time that this player last
connected to the MUD.  The integer is in the format returned by the
@code{time()} primitive, i.e., the number of seconds elasped since 1
January 1970, GMT.
@end defvr

@defvr Property ownership_quota
This property stores the current quota for the player.  It is not
accessible by the player, to prevent you increasing your building quota
arbitrarily.  This field can be only changed by a wizard.
@end defvr

@defvr Property gender
This property is used to hold a string representing the gender of the
player.  In the normal case, this is one of @samp{male}, @samp{female},
@samp{neuter}.  This property is affected by the @samp{@@gender} command.
@end defvr

@defvr Property ps
This property is used to hold the subjective pronoun, set to either
"he", "she" or "it" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%s"}
with the value of this property.
@end defvr

@defvr Property po
This property is used to hold the objective pronoun, set to either
"him", "her" or "it" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%o"}
with the value of this property.
@end defvr

@defvr Property pp
This property is used to hold the possessive pronoun, set to either
"his", "her" or "its" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%p"}
with the value of this property.
@end defvr

@defvr Property pr
This property is used to hold the reflexive pronoun, set to either
"himself", "herself" or "itself" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%r"}
with the value of this property.
@end defvr

@defvr Property pq
This property is used to hold the possessive pronoun in it's noun form,
set to either "his", "hers" or "its" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%q"}
with the value of this property.
@end defvr

@defvr Property psc
This property is used to hold the subjective pronoun, set to either
"He", "She" or "It" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%S"}
with the value of this property.
@end defvr

@defvr Property poc
This property is used to hold the objective pronoun, set to either
"Him", "Her" or "It" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%O"}
with the value of this property.
@end defvr

@defvr Property ppc
This property is used to hold the possessive pronoun, set to either
"His", "Her" or "Its" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%P"}
with the value of this property.
@end defvr

@defvr Property prc
This property is used to hold the reflexive pronoun, set to either
"Himself", "Herself" or "Itself" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%R"}
with the value of this property.
@end defvr

@defvr Property pqc
This property is used to hold the possessive pronoun in it's noun form,
set to either "His", "Hers" or "Its" as appropriate.
@code{string_utils:pronoun_sub} replaces the string @code{"%Q"}
with the value of this property.
@end defvr

@defvr Property home
This property stores the object number of the player's @dfn{home}.  This
is the place that the player is taken to when s/he types in @samp{home}.
The home room is normally either a general sleeping area, or the player's hotel
room or apartment.
@end defvr

@defvr Property password
This property stores the encrypted password used to connect to the
LambdaMOO server as this player.  It is changed by using the
@samp{@@password} command, and is checked by the server upon login.
@end defvr

@defvr Property gaglist
This property stores a list of object numbers.  Any output received,
using @code{$player:tell} from any of the objects in the list is
filtered out of the text sent to the player's terminal screen.  Items
are added and deleted to this list using the @samp{@@gag} and
@samp{@@ungag} commands.
@end defvr

@defvr Property paranoid
This property is an integer, representing the @dfn{paranoid level} of
the player.  If set to @samp{2}, any output received by the player, via
@code{$player:tell} is prefixed with the name of the object that
originated the message.  This is used to that a player can detect spoof
output from other players or objects.

If set to @samp{1}, any messages sent using @code{$player:tell} are
stored in a small cache in the property @code{responsible}, along with
details of where the message came from.  This can be used for later
checking with the @samp{@@check} command.

If set to @samp{0}, no spoof checking is performed.  This is the normal
case. 
@end defvr

@defvr Property responsible
This property stores a list in the following format:

@example
@{@var{callers}, @var{text}@}
@end example

@noindent
The @var{callers} part is in the same format returned by the
@code{callers()} primitive, and lists the @dfn{verb stack} at the time
that the message stored in @var{text} was sent.

This property is set by @code{$player:tell} and looked at by
@code{$player:@@check}.  It contains a maximum number of entries, as
determined by the value of the @code{lines} property on the player.
@end defvr

@defvr Property lines
This property stores the number of lines kept in the property
@code{responsible} for anti-spoof checking.
@end defvr

@defvr Property object_gaglist
This property holds a list of objects that are in the player's
@dfn{gaglist}.  Any output from these objects is ignored by the player's
@code{:tell} verb.
@end defvr

@defvr Property page_absent_msg
This property holds the message sent to someone when they try to page
the player while s/he is not connected.   It may contain the usual
pronoun substitutions.  The default value is @samp{%n is not currently
logged in.}
@end defvr

@defvr Property page_origin_msg
This property holds the message sent to a player you page, telling them
where you are.  The default message is @samp{You sense that %n is
looking for you in %l.}
@end defvr

@defvr Property page_echo_msg
This property holds the message sent to a player that pages you when you
are logged in.  The default message is @samp{Your message has been
sent.}
@end defvr

@defvr Property whereis_location_msg
This property holds the message sent when someone locates you through
the @samp{@@whereis} command.  The default message is @samp{%N (%#) is
in %l (%[#l]).}  This might expand out to something like

@example
Blip (#35) is in The Toilet (#96).
@end example
@end defvr

@defvr Property who_location_msg
This property holds the message printed in a @dfn{who list} to inform
other player's of your location.  The default value is @samp{%l}, which
returns your current location.
@end defvr

@defvr Property mail_notify
@defvrx Property mail_options
@defvrx Property mail_forward
These properties define your MOO mail environment.  They are discussed
in more detail in the section on the MOO Mail system.
@end defvr

@defvr Property edit_options
This property defines your MOO editor environment.  It is discussed in
more detail in the section on the MOO editor.
@end defvr

@section The Mail Room Class

*** To be updated for MOO 1.3 ***

This class provides the mail facility used within LambdaMOO. Some would
say that to provide an electronic mail facility within a game is
slightly insane, but it is very useful for passing around game related
messages.  Coupled with the use of a suitable client program, for
example the excellent @code{mud.el} with MOO Mail extensions, sending MOO
mail can be easy and efficient.  It also allows players to separate
their MOO based mail from other, more important mail.

LambdaMOO does not yet provide any facility for reading input from a
player.  For this reason, programs such as the mail room use a
pseudo-room to catch player input.  For example, when you start to
compose a mail message, you are transported to the mail pseudo-room.
Once there, anything you enter is trapped by various verbs in the room,
and stored in the message you are entering.

This method means that commands used in the mail composition
environment are actually verbs on the mail pseudo-room.

Mail messages are actually stored on the player object, in a property
list called @code{messages}.  Each message occupies one entry, called a
@dfn{mail record}, in the following format:

@example
@{@var{num}, @{@var{date}, @var{from}, @var{to}, @var{subject}, @var{line1}, @dots{}, @var{lineN}@} @}
@end example

@noindent
Apart from the @var{num} field, these are all strings.  The @var{num}
field stores the message number for each message.  When a new piece of
mail arrives, it is allocated a message number 1 greater than the last
message in the player's mailbox.  If the mailbox is empty, the message
is numbered @samp{1}.  Each message retains it's unique message number
until it is deleted using @samp{@@rmmail}.

The number of messages in the mailbox is given by the length of the
messages list.  A @dfn{current message} pointer is maintained in the
property @code{$player.current_message}.  This is used to determine
which message to print when the @samp{@@read} command is used.

The MOO Mail system is implemented by four separate objects, and some
verbs on the @code{$player} class:

@itemize @bullet
@item
The Mail Room/Editor @code{($mail_room or $mail_editor)}.  This room
is the place where mail messages are composed.  It also contains a
number of mail utility verbs.  The mail editor is a child of the
@code{Generic Editor}.
@item
The Mail Distribution Center @code{($mail_agent)}.  This is a child of
@code{$root_class} and has verbs used to handle mail distribution.  It
is also the database of @dfn{mailing lists} and @dfn{mail folders}.
@item The Generic Mail Recipient @code{($mail_recipient)}. This is a special
class used to set up @dfn{mailing lists} and @dfn{folders}.
@item
The Player Class @code{($player)}.  This class holds various player
commands used to deal with the MOO Mail system.
@end itemize

The sections that follow detail the verbs in each of the classes, along
with any relevant properties.

@subsection Mail Commands and Properties on The Player Class
A number of verbs are defined in the @code{$player} class to provide
access to the mail system.  These verbs are detailed below:
 
@deftypefn Verb none @@mail (@var{args})
This command is used to list the messages currently stored in the
player's mailbox.   Mail messages are stored in the property list
@code{messages} on the player.  This is a list of complete messages,
stored one per list item, in the format shown above.  

The @samp{@@mail} command first checks the current message number still
exists, using the verb @code{this:fix_current_message}.  It then
attempts to parse the arguments given to it, to get a set of message
numbers that the user wishes to have displayed.  The possible arguments
are as follows :-

@display
@table @code
@item cur
- the current message
@item new
- all messages after the current message
@item @var{num}
- (where @var{num} is a number) the message numbered @var{num} if there is one.
@item @var{num1}-@var{num2}
- all messages in the given range, if any.
@item last:@var{num}
- the last @var{num} messages
@item -@var{num}
- the last @var{num} messages
@end table
@end display

These may be combined on the @samp{@@mail} command line.  When a list of
messages to display has been gathered in the variable @code{msglist},
the following code is used to display the list to the user:

@example
for x in (msglist)
  msg_num = x[1];
  player:tell(this.current_message == msg_num ? "-> " | "   ", 
              $string_utils:right(msg_num, 2), ":  ", 
	      $mail_recipient:summary_line(x[2]));
endfor
@end example

For example,
@example
You have 3 messages:
    1:  May 30 12:18   Ezeke (#57)   Classes Documentation
    2:  Jun  4 19:35   Ezeke (#57)   Room contents using title()
->  3:  Jun  5 10:23   Ezeke (#57)   Potential problems
@end example

@noindent
The pointer, @samp{->} indicates the current message.  The date, subject
and sender of each message, along with the message number, is taken from
the relevant mail record stored in the player's @code{messages} property.
@end deftypefn

@deftypefn Verb none @@rmm*ail (@var{args})
This command is used to delete mail from the player's mailbox property,
@code{messages}.  The verb takes each message number given as an
argument, and searches for the message in the player's mailbox.  If an
argument is the string @samp{cur}, then this is taken as the number of
the current message.

If a match is found, by checking the first entry in each @dfn{mail
record}, the message is removed from the @code{messages} property list.
If a message is not found, the player is informed with a suitable
message.
@end deftypefn

@deftypefn Verb none @@send @var{player1} @var{player2} @dots{}
This command is used to send mail messages to other players.  The verb
simply calls 

@example
$mail_editor:invoke(args, verb, this.mail_options)
@end example

@noindent
to start composition of a message. 
@end deftypefn

@deftypefn Verb none @@read
@deftypefnx Verb none @@read @var{num1} @var{num2} @dots{}
This command is used to read mail messages in the player's mailbox.  If
no argument is given, the @dfn{current message} is displayed on the
player's terminal screen.  If a list of one or more message numbers is
given, each message is printed out, in turn.  

The verb first checks to see if an argument has been given.  If this is
not the case, it attempts to get the current message number, and use
this as the argument.  If there are no messages, or no possible current
message, the verb is aborted with a warning message to the player.

Once the message number(s) to display has been decided,  a loop is
entered which lists each message in turn.  For each message number given
the mailbox is searched for the message with that number.   If no
message is found with a given number, a warning message is sent to the
user.

Printing a message simply involves printing the message number, and the
message text - the second item in the mail record.
@end deftypefn

@deftypefn Verb none @@answer
@deftypefnx Verb none @@answer @var{msg}
@deftypefnx Verb none @@reply
@deftypefnx Verb none @@reply @var{msg}
This command is used to reply to a message sent by another player.  If
no argument is given, the current message number (if valid) is taken to
be the message to reply to.  Once a valid message has been located in
the player's @code{messages} property, the verb

@example
$mail_editor:invoke(2, verb, x[2], @{@@this.mail_options, @@args@});
@end example

@noindent
is invoked to allow the player to compose a reply, where @var{x} is the
message being replied to.
@end deftypefn

@deftypefn Verb num receive_message (list @var{message})
This function is called by other mail system verbs to place a message in
the player's mailbox property, @code{messages}.  If the calling verb has
permission to modify the properties on the player, the message is simply
added to the end of the current list of messages, and given a message
number one greater than the maximum current message number.

A notification is sent to the player, informing him/her that new mail
has arrived.  The verb returns @samp{1} for a successful delivery, and
an error code (normally @code{E_PERM}) otherwise.
@end deftypefn

@deftypefn Verb none fix_current_message ()
This verb is used to validate the @dfn{current message} number property
on the player.  For example, if a player deletes the current message,
then the number stored in the @code{current_message} property no longer
points to a valid message.  This verb checks through all the messages in
the mailbox, @code{player.messages}, until it finds message number
@code{current_message}, or it passes the place in the list where the
current message is supposed to be.  If this happens, the current message
property is set to the next message along in the list.  If this does not
produce a valid message number, then the current message is taken to be
the last message on the list, or @samp{0} if there are no more messages.
@end deftypefn

@deftypefn Verb none @@next ()
This command is used to advance the current message pointer to the next
message in the player's mailbox.  This is done by incrementing the
pointer, and then calling @var{$player:fix_current_message} to validate
it.  If there is no message after the current message, the pointer is
moved off the list.

Once a new current message has been found, it is printed out using the
@code{$player:@@read} verb.
@end deftypefn

@deftypefn Verb none @@prev ()
This command is used to backtrack the current message pointer to the
previous message in the player's mailbox.  This is done by looking for
the current message in the message list, and then decrementing the index
that expression returns by one place.

Once a new current message has been found, it is printed out using the
@code{$player:@@read} verb.
@end deftypefn

@deftypefn Verb none @@renumber ()
This verb is used to renumber the messages in a player's mailbox to all
consecutive numbers, starting from one.  After checking that the person
invoking the verb has permission to perform the renumbering, and there
are messages to renumber, the verb executes the following code:

@example
newmsgs = @{@};
i = 0;
for x in (this.messages)
  newmsgs = @{@@newmsgs, @{i = i + 1, x[2]@}@};
endfor
this.messages = newmsgs;
@end example

@noindent
which is fairly self explanatory. The current message number is
preserved by getting it's index in the list of messages.  This is the
number that the message will have after the renumbering operation.
@end deftypefn

@subsection The Mail Room or Mail Editor
When a player wishes to send a mail message, s/he is transported to the
mail room to compose the message.  This room is a child of the generic
editor, and provides all the functions documented in the section on that
class.  In addition, it provides verbs and properties related
specifically to the sending of mail messages.  The following section
describes each of the @code{$mail_room} verbs and properties in detail.

@deftypefn Verb string working_on (num @var{who})
This verb returns a string describing the mail message currently being
worked on by the player identified by @var{who}.  It executes the
following code:

@example
return this:ok(who = args[1]) && "a letter to " + 
               this:recipient_names(who) + 
               ((subject = this.subjects[who]) && 
               " entitled \"" + subject + "\"");
@end example
@end deftypefn

@deftypefn Verb list parse_invoke (@var{args})
This verb parses the arguments given to @code{$mail_room:invoke} to
determine the type of mail editor invocation required - either produced
by an @samp{@@answer} or a @samp{@@send} command.  In the latter case,
the arguments passed to @code{$mail_room:invoke} are

@example
invoke(@var{rcpts}, @var{verb}, @var{flags} [, @var{subject}])
@end example

@noindent
The argument @var{rcpts} is a list of recipients for the message.  This
list is parsed using the verb @code{$mail_room:parse_recipients()}.
The @var{flags} parameter is a list of possible mail options.  In this
case, it is searched for the @code{replyto} option, and a variable set
if it is found.  The parameter @var{subject} can optionally give the
subject for the message.  For an @samp{@@send} command, the returned
list from this verb contains the following information:

@example
@{list @var{rcpts}, str @var{subject}, str @var{replyto}, @{@}@}
@end example

For an @code{@@answer} command, the arguments are

@example
invoke(2, @var{verb}, @var{msg}, @var{flags})
@end example

@noindent
For answering a message, a different set of information is given and
returned.  The verb @code{$mail_editor:parse_msg_headers} is used to
parse the options given by the player into a variable @var{hdrs}.

Several options can be specified in this way to the @samp{@@answer}
command. as shown below.

@display
@table @code
@item incl
- include the original message text.
@item all
- reply to everyone in the mail header.
@item sender
- reply to the sender only.
@item noincl
- do not include the original message in your reply.
@end table
@end display

If the @samp{incl} option is given, the original message text is placed
into a variable @var{incl} for returned to the calling verb.  Every line
is prepended with the characters @var{ >}, as one would expect.

The list shown below is returned to the calling verb:

@example
@{@var{hdrs}, @var{include}@}
@end example

@noindent
where @var{hdrs} is the list returned by parsing @var{msg} supplied to
the verb, and @var{include} contains any included message text.

If any problem is encountered in parsing the message headers, or in
recognising which command originated the call to this verb, @samp{0} is
returned.
@end deftypefn

@deftypefn Verb none init_session ()
@end deftypefn

@deftypefn Verb none pri*nt ()
@end deftypefn

@deftypefn Verb none print_msg ()
@end deftypefn

@deftypefn Verb none message_with_headers ()
@end deftypefn

@deftypefn Verb none subj*ect: ()
@end deftypefn

@deftypefn Verb none set_subject ()
@end deftypefn

@deftypefn Verb none to*: ()
@end deftypefn

@deftypefn Verb none also*-to: cc*: ()
@end deftypefn

@deftypefn Verb none parse_recipients ()
@end deftypefn

@deftypefn Verb none recipient_names ()
@end deftypefn

@deftypefn Verb none make_message ()
@end deftypefn

@deftypefn Verb none name_list ()
@end deftypefn

@deftypefn Verb none parse_msg_headers ()
@end deftypefn

@deftypefn Verb none check_answer_flags ()
@end deftypefn

@deftypefn Verb none reply-to*: replyto*: ()
@end deftypefn

@deftypefn Verb none send ()
@end deftypefn

@deftypefn Verb none who ()
@end deftypefn

@deftypefn Verb none showlists ()
@end deftypefn

@deftypefn Verb none send_message ()
@end deftypefn

@deftypefn Verb none subsc*ribe ()
@end deftypefn

@deftypefn Verb none unsubsc*ribe ()
@end deftypefn

The following properties are also defined on the @code{$mail_editor} or
@code{$mail_room} class:

@defvr Property replytos ()
@end defvr

@defvr Property recipients ()
@end defvr

@defvr Property subjects ()
@end defvr


@deftypefn Verb num accept (obj @var{thing})
This verb overrides the @code{$room} class definition.  In this case,
@var{thing} is allowed to enter the room only if it is in the list
@code{$mail_room:writers}.  In practice, this stops anyone from moving
into the room, unless they have used a mail system command that enters
their object number into the list of @dfn{message writers}.  This is
necessary because the action of entering the room causes certain mail
related state to be setup.  

Note that the normal way to enter the mail room is to use the
@samp{@@send}, for example.  When a player enters the room using one of
the mail commands, s/he is added to the list of writers.  If, for some
reason, the player has to @samp{@@move} out of the room, then s/he can
move back in using @samp{@@move} because s/he is in the
@code{$mail_room:writers} list.
@end deftypefn

@deftypefn Verb none enterfunc (obj @var{player})
This function is triggered when a player moves into the room by the
LambdaMOO server.  It performs a number of actions related to setting up
the state of the mail room ready for the user to interact with the mail
system.  The code for this verb is shown below:

@example
who = args[1];
recips = this:recipient_names(who);
if (this:message_so_far(who))
  player:tell("You are in the middle of writing a letter to ", 
          recips, ".  To discard that message, type 'abort'.");
  this:print_msg(who);
else
  player:tell("Sending a message to ", recips, " ...");
  pass(@@args);
endif
@end example

First, we get the list of recipients for the mail message (specified
before the player has entered the room).  If the player already has part
of a message stored in the mail room, then s/he is allowed to continue
the message.

Finally, @code{pass()} is used to invoke the @code{$room} class verb
@code{:enterfunc}.
@end deftypefn

@deftypefn Verb none add_writer (obj @var{player}, list @var{recipients})
This verb is used to add a plyer to the list of people composing letters
in the mail room.  Only players are allowed to do this.  If the player
is not already composing a message, then s/he is simply added to the
list of @dfn{writers} for the room.  This causes @var{player} to be
added to the @code{$mail_room:writers} property.

In addition to this, the @code{recipients} list is added to the list,
@code{$mail_room:recipients}.  The original location of the player
(before being moved to the mail room) is stored in the
@code{$mail_room:places} list.  The subject line and message text for
this message is set to the empty string, in the property lists
@code{$mail_room:subjects} and @code{$mail_room:messages}.  The message
is also marked as being abortable, by adding a @samp{0} to the
@code{$mail_room:abortable} list.  This is done because there is no
warning given for deletion of an empty message.

If the player is already in the list of people composing messages in the
mail room, then the @code{listset()} primitive is used to change the
recipients, subject and abortable property for the message associated
with the player.  This means that a player can only be composing one
message at a time.

Once the above has been performed, the player is moved from his/her
current location to the mail room.  A suitable message is sent to all
the objects in the player's current location telling them what has
happened.

Throughout all user interaction in the mail room, the position of the
player object reference in the @code{$mail_room:writers} list is used to
index into all the other property lists used when dealing with a mail
message. 
@end deftypefn

@deftypefn Verb list recipients (obj @code{player})
This verb returns the list of recipients for the message being composed
by @var{player}.
@end deftypefn

@deftypefn Verb list message_so_far (obj @var{player})
This verb returns the text of the message currently being composed by
@var{player}.  This is returned as a list of strings.
@end deftypefn

@deftypefn Verb none say (string @var{text})
This verb overrides the @code{$room} class definition.  It is
intercepted to allow the mail program to capture input from the user to
append to the message currently being composed.  The
@code{$mail_room:say} verb itself just passes the player object
reference and @var{text} to the @code{$mail_room:add_line} verb for
processing.
@end deftypefn

@deftypefn Verb none emote (string @var{text})
This verb overrides the @code{$room} class definition.  It is
intercepted to allow the mail program to capture input from the user to
append to the message currently being composed.  The
@code{$mail_room:say} verb itself just passes the player object
reference and @var{text}, with the player name prepended, to the
@code{$mail_room:add_line} verb for processing.

This allows both @samp{say} and @samp{emote} input to be captured in the
current message.
@end deftypefn

@deftypefn Verb none add_line (obj @var{player}, string @var{text})
This verb is used to add @var{text} to the current message being
composed by @var{player}.  Once a line has been added to a text message,
it is not allowed to be immediately aborted.  This is set using the
@code{$mail_room:clear_abortable} verb.
@end deftypefn

@deftypefn Verb none print ()
This verb is a player command used to print the text stored in the
current message.  The code itself first allows the message to be
aborted, using @code{$mail_room:clear_abortable}, and then calls
@code{$mail_room:print_msg} to print the message text.
@end deftypefn

@deftypefn Verb none print_msg (obj @var{player})
This verb prints the text of the current message being composed by
@code{player}.  Again, the code is fairly simple, and is shown below:

@example
who = args[1];
who:tell("Your message so far:");
who:tell();
who:tell_lines(this:message_with_headers(who));
who:tell();
who:tell("<End of message>");
@end example

Note the use of the @code{$root_class:tell_lines} verb to print the message
contents.  @code{$mail_room:message_with_headers} returns a list of
strings comprising the mail header, and message text.
@end deftypefn

@deftypefn Verb list recipient_names (obj @var{player})
This verb returns a list of the names of the recipients of the current
message being composed by @code{player}.  It retrieves the correct list
of recipients from the @code{$mail_room:recipients} property list, and
then maps this from a list of object references to a list of object
names using @code{$mail_room:name_list}.
@end deftypefn

@deftypefn Verb none pause ()
This is a player command used to temporarily stop composition of a
message by a player.  A suitable message is printed by the player, and
then the @code{$mail_room:send_back} verb is invoked to send the player
back to the room s/he was in when letter composition was started.
@end deftypefn

@deftypefn Verb none send_back (obj @var{player})
This verb is used to return a player to the room s/he was in when a
letter composition command was invoked.   When a player enters the mail
room, the original location of the player is stored in the property list
@code{$mail_room:places}.  This verb causes that location to be looked
up, and the player is returned to his/her original location.  A suitable
message is sent to the objects in the player's original location to
inform them that s/he has returned from the mail room.
@end deftypefn

@deftypefn Verb none look_self ()
This verb overrides the @code{$room} class definition.  This is done to
inhibit the room name and contents list being printed when the player
uses the @samp{look} command.  Instead, this verb uses
@code{$mail_room:description} as help text, which is sent to the player
using @code{$root_class:tell_lines}.
@end deftypefn

@deftypefn Verb none help ()
This verb is a player command invoked to get some help on the mail room
facilities.  This results in the @code{$mail_room:look_self} verb being
called to print the help text stored in the mail room description.  Note
that this overrides, also, the LambdaMOO help system.
@end deftypefn

@deftypefn Verb none abort ()
This is a player command used to abort composition of a message, and
throw the text away.  A check is made to see if the message is
abortable.  If it is, then the player is sent back to his/her original
location, and the message is destroyed using @code{$mail_room:destroy}.

If this message is marked as being non-abortable, the player is given an
@samp{Are you sure?!} message.  The @code{$mail_room:abortable} property
is used to provide a safety net for players.  Typing @code{abort} once
will not throw away the message, unless it is empty. 
@end deftypefn

@deftypefn Verb num abortable (obj @var{player})
This verb is used to return the @code{abortable} status of the message
currently being entered by @code{player}.  The
@code{$mail_room:abortable} property list contains a boolean value for
each player currently composing a message.  The mechanism is included to
stop a player accidentally deleting a message by using the @samp{abort}
command.  If the @code{abortable} flag for a message is set, then the
message may be deleted by using the @samp{abort} command.  If the flag
is clear, then deletion is prevented.

One invocation of @samp{abort} results in an @samp{Are you sure?!}
message being printed, and the @code{$mail_room:abortable} flag for the
player's message is reset to allow aborts.  A subsequent @samp{abort} by
the player will then destroy the message.

An empty message can be aborted without any warning.  Once a line of
text has been entered into a message, this saftey feature is enabled by
clearing the @code{abortable} flag for the message.
@end deftypefn

@deftypefn Verb none set_abortable obj @var{player}
This verb is used to set the @code{$mail_room:abortable} flag for the
message currently being composed by @var{player}.   If the flag is set,
the message is allowed to be aborted.
@end deftypefn

@deftypefn Verb none clear_abortable ()
This verb is used to clear the @code{$mail_room:abortable} flag for the
message currently being composed by @var{player}.   If the flag is
reset, the message cannoted be aborted.
@end deftypefn

@deftypefn Verb none exitfunc obj (@var{player})
This verb is invoked when a player leaves the mail room.  It clears the
@code{abortable} flag for the @var{player}'s message, and then invokes
the @code{exitfunc} of the parent class.
@end deftypefn

@deftypefn Verb none destroy (obj @var{player})
This verb is used to delete the message currently being composed by
@var{player}.  This involves removing the message state from the various
property lists stored in the room.  The code for this verb is shown
below, as the best explanation:

@example
who = args[1];
pos = who in this.writers;
this.writers = listdelete(this.writers, pos);
this.recipients = listdelete(this.recipients, pos);
this.messages = listdelete(this.messages, pos);
this.places = listdelete(this.places, pos);
this.abortable = listdelete(this.abortable, pos);
this.subjects = listdelete(this.subjects, pos);
@end example
@end deftypefn

@deftypefn Verb none send ()
This verb is a player command invoked to send the current message to the
list of recipients.  It retrieves the message as a list of strings, and
then sends it to each recipient in turn.  Note that no third part mail
agent is involved.  When the @samp{send} command is invoked by a player,
it delivers mail to the recipients using the verb
@code{$player:receive_message}.

After a message has been sent, it is destroyed.  The invoking player is
returned to the room s/he was in when the mail system was started.
@end deftypefn

@deftypefn Verb list message_with_headers (obj @var{player})
This verb returns a list of strings, giving the message plus any headers
which are added to the front by the mail system.  The
@code{$mail_room:make_message} verb is used to produce the list of
strings.
@end deftypefn

@deftypefn Verb string the_subject (obj @var{player})
This verb returns the subject text for the message being composed by
@var{player}.  This is done by retrieving the correct entry from the
property list @code{$mail_room:subjects}.
@end deftypefn

@deftypefn Verb none sub*ject ()
This is a player command used to set the subject text of the current
message.  A simple call is made to the @code{$mail_room:set_subject}
verb, with the arguments supplied by the player in @code{argstr}.
@end deftypefn

@deftypefn Verb none to ()
This is a player command used to set the list of recipients for the
current message.  Without any arguments, the command prints the current
list of recipients.  If one or more arguments are supplied, then the
recipients list for the message is cleared, and the verb
@code{$mail_room:also-to} is invoked to take tge player arguments, and
set the message recipients list accordingly.
@end deftypefn

@deftypefn Verb none set_subject (obj @var{player})
This verb is used to set the subject text for the message being composed
by @var{player}.
@end deftypefn

@deftypefn Verb none also*-to (string @var{args})
This verb goes through the list of names given in @var{args} adding each
name to the recipients list for the current message.  The code for the
verb is shown below:

@example
pos = player in this.writers;
recips = this.recipients[pos];
for x in (args)
  r = $string_utils:match(x, players(), "aliases");
  if (r == $failed_match)
    player:tell("There is no player named '", x, "'.");
    return;
  elseif (r == $ambiguous_match)
    player:tell("I don't know which '", x, "' you mean.");
    return;
  endif
  recips = setadd(recips, r);
endfor
this.recipients = listset(this.recipients, recips, pos);
player:tell("Your message is now to ", this:recipient_names(player), ".");
@end example

Each name in the argument list is matched to a player name.  If there is
no match, the name is rejected from the list of recipients, and further
processing is aborted. If there is a match, the player object reference
is added to the list of recipients.  If there is an ambiguous match, the
name is ignored, and further processing is aborted.

Valid names are added one by one to the recipient list for the message.
@end deftypefn

@deftypefn Verb list make_message (obj @var{player}, list @var{to}, string @var{subj}, list @var{msg})
This verb returns the message as it will be sent to the recipients in
the list @var{to}.  It takes the arguments given, and puts together a
list of strings that gives the current message being written by
@var{player}.  In addition to the supplied arguments, the date and
sender's name are added to the message as header.
@end deftypefn

@deftypefn Verb string name_list (list @var{names})
This verb returns an english style list of the names in @var{names}.
@end deftypefn

@deftypefn Verb none send_message (obj @var{from}, list @var{to}, string @var{subj}, list @var{msg})
This verb is used to actually send a mail message to the players given
in the @var{to} list of recipients.  If you wish to send mail from
another verb, this is the verb to use.  The arguments given are passed
to @code{$mail_room:make_message} for formatting, and then sent to each
of the recipients in turn.
@end deftypefn


The following properties are defined for the @code{$mail_room} class.
Each property contains a list of items, one per player currently
composing a letter.  The index of the player in the @code{writers} list
is used to locate the correct entries for that player's message in all
the other property lists.

@defvr Property subjects
This is a list of strings.  Each string contains the subject line for a
message currently being composed.
@end defvr

@defvr Property abortable
This is a list of boolean (number) values.  If set, the relevant message
can be aborted by the player using the @samp{abort} command in the mail
room.  If not set, the message cannot be aborted.
@end defvr

@defvr Property places
This is a list of room object references.  When a player enters the mail
room, using one of the mail composition commands, his/her current
location is stored here.  When the player has finished in the mail room,
s/he is returned to the original room.
@end defvr

@defvr Property recipients
This is a list of lists of object references, referring to players.
Each entry in the list looks like the following :

@example
@{@var{player1}, @var{player2}, @dots{}, playerN@}
@end example

@noindent
The message currently being composed will be sent to @var{player1} thru
@var{playerN} when it is @samp{sent}.
@end defvr

@defvr Property messages
This property stores the actual message text being composed by the
player.  Each entry in the list is a list of strings, one per line of
the message.
@end defvr

@defvr Property writers
This is the list of players currently engaged in composing a message in
the mail room.  Every time a player enters the mail room using one of
the mail commands, his/her object reference is added to this list.  If a
player enters the mail room and is already on this list, this indicates
a resumption of a previously @samp{pause}d mail session.
@end defvr

@subsection The generic Editor Class
This class provides a basic MOO code editing facility for those players
who do not have access to an external editor such as Emacs.  It provides
basic facilities for editing and compiling MOO code on verbs, but cannot
be considered complete or extensive.

@subsection The System Object Class
The @dfn{system object} class is the fundamental cornerstone of the
whole LambdaMOO database.  It is the first item in the database, and
hence has an object number of @samp{#0}.  It has no verbs defined on it,
but a number of interesting properties that are used to determine the
behaviour of parts of the LambdaMOO server and Core functions.

In particular, properties defined on the root class can be referred to
using the @samp{$} notation as a shorthand.  For example, if I define a
property called 

@example
#0.foobar = #1234
@end example

@noindent
then I can refer to @samp{#1234} thereafter using the shorthand 

@example
$foobar
@end example

@noindent

Shorthand references are provided for all of the base classes.  If a new
public class is added, it should be given a shorthand by adding a
suitable property to the system object, @samp{#0}.  In this way, players
can refer to the shorthand when creating objects that belong to the new
class.

For example, if @code{foobar} were the name of a new class, then I could
use

@example
@@create $foobar named gadget
@end example

@noindent
to create an instance of the class @code{foobar}.

Shorthand notation is provided in the following properties.  Most of
them refer to public classes.  A few refer to other, global values that
are used in the database.

@defvr Property editor
@end defvr

@defvr Property mail_room
@end defvr

@defvr Property object_utils
@end defvr

@defvr Property lock_utils
@end defvr

@defvr Property list_utils
@end defvr

@defvr Property command_utils
@end defvr

@defvr Property player
@end defvr

@defvr Property wiz
@end defvr

@defvr Property prog
@end defvr

@defvr Property code_utils
@end defvr

@defvr Property help
@end defvr

@defvr Property nothing
This should be used similarly to a @code{void} pointer in C.
@end defvr

@defvr Property failed_match
This is the value used in all matching verbs to indicate that nothing matched.
@end defvr

@defvr Property ambiguous_match
This value is used in matching verbs to indicate that more than one
possible result was found.
@end defvr

@defvr Property perm_utils
@end defvr

@defvr Property building_utils
@end defvr

@defvr Property string_utils
@end defvr

@defvr Property news
@end defvr

@defvr Property note
@end defvr

@defvr Property letter
@end defvr

@defvr Property container
@end defvr

@defvr Property thing
@end defvr

@defvr Property exit
@end defvr

@defvr Property room
@end defvr

@defvr Property root_class
This points to the class from which everything else is descended.
@end defvr

The other properties defined for the system object are listed below,
with details given as to their function and derivation.

@defvr Property wizard_mail_recipients
This property is a list of object numbers.  It gives a list of people
who will receive mail sent by players to the wizard.  This can
loosely be interpreted as being a list of players that are involved in
running the game, and are not strictly wizards.
@end defvr

@defvr Property gripe_recipients
This property is a list of object numbers.  It gives a list of people
who will receive mail sent by players using @samp{@@gripe}.  This can
loosely be interpreted as being a list of players that are involved in
running the game, and are not strictly wizards.
@end defvr

@defvr Property dump_interval
This property specified the interval between database dumps, in seconds.
The default value is 600 seconds, which is every ten minutes.  A
database dump should be initiated at regular intervals to provide a
backup in case the LambdaMOO server crashes, or the host machine goes
down.
@end defvr

@defvr Property welcome_message
This property is a list of strings containing the message sent to
players when they log in to the LambdaMOO server.  It should be used to
convey simple help information to first time players, as well as making
urgent announcements that you wish everyone to see.
@end defvr

@defvr Property player_start
This is an object reference of the starting room for new players.  When
a player is created, using the @samp{create} command when initially
connecting to the LambdaMOO server, s/he is placed in the
@code{$player_start} room.  This is also set as the default
home for a new player.  If you wish to place new players into a
different starting room, then you should change the object reference
stored in @code{$player_start}.
@end defvr

@defvr Property player_class
This is an object reference for the class that newly created players
belong to by default.    The initial value of this property is
@code{$player}.  If you create an enhanced player class that you wish
all new players to belong to, you should change the value of this
property to be the object reference of the new, enhanced player class.
@end defvr

@subsection The Container Class
A container is a an object that can hold other object inside itself.
This is similar to the idea of a room,  except that a container has no
notion of exits, and can only hold things;  it cannot hold players.

The following verbs are defined for the container class.

@deftypefn Verb none d*rop (obj @var{object})
@deftypefnx Verb none in*sert (obj @var{object})
@deftypefnx Verb none p*ut (obj @var{object})
This verb puts @var{object} into the container.  The container is first
checked to verify that it is open, if not an error message is printed.

For example, if you have a container named @var{pipe} and an object named
@var{tobacco}, you could enter:

@example
put tobacco in pipe
@end example

@noindent
If @var{pipe} is open, then @var{tobacco} will be put into the
@var{pipe}.  If you look at @var{pipe} you should see:

@example
pipe
Contents:
  tobacco
@end example
@end deftypefn

@deftypefn Verb none g*et (obj @var{object})
@deftypefnx Verb none ta*ke (obj @var{object})
@deftypefnx Verb none re*move (obj @var{object})
This does the opposite of the put/insert/drop commands.  To remove the
@var{tobacco} from the @var{pipe} you would enter:

@example
remove tobacco from pipe
@end example

@noindent
When you look at @var{pipe} now you should see:

@example
pipe
It is empty.
@end example
@end deftypefn

@deftypefn Verb none open ()
This verb will open the container and allow objects to be put into it
(via the @var{put} verb).  This verb sets the property @var{opened} to
@samp{1}. 
@end deftypefn

@deftypefn Verb none @@lock_for_open (obj @var{object})
This verb will lock the container with @var{object}.  The container can
only be opened if the player is holding @var{object}, or the
@var{object} is the player trying to open the container.  The container
will remained locked until it is unlocked (see below).
@end deftypefn

@deftypefn Verb none @@unlock_for_open ()
This verb will remove the lock set by @var{@@unlock_for_open}.  It can
only be run by the owner of the container.
@end deftypefn

@deftypefn Verb num is_openable_by (obj PLAYER)
This verb uses the @code{$lock_utils:eval_key} verb to determine if the
container can be opened by the player.  The verb will return @samp{1} if
the player has permission to open the container, and @samp{0} otherwise.
@end deftypefn

@deftypefn Verb none close ()
This is the opposite of @var{open}.  If the pipe is already close, an
error message is printed.
@end deftypefn

@deftypefn Verb none tell_contents ()
This verb displays the contents of the container.  If the container is
empty, the message @samp{It is empty} is displayed.
@end deftypefn

@deftypefn Verb none set_opened (int @var{number})
This verb is called by @var{open} and @var{close}, with the arguments
@samp{1} and @samp{0} respectively.  The property @var{opened} is set to
either @samp{1} (opened) or @samp{0} (closed).
@end deftypefn

@deftypefn Verb none @@opacity (int @var{number})
Opacity determines when/if you can look at the contents of the
container.  There are three levels of opacity:

@example
0 - transparent
1 - opaque
2 - black hole
@end example

@noindent
When the opacity is set to 0, you can see the contents when the pipe
is open or closed.  When the opacity is set to 1, you can only see the
contents when the container is open.  If opacity is set to 2, you can
never see the contents when looking at the container.  

@noindent
The syntax for @samp{@@opacity} is:

@example
@@opacity container is #

where '#' is either 0, 1 or 2.
@end example
@end deftypefn

@deftypefn Verb int set_opaque (int @var{number})
This verb is called by @samp{@@opacity}.  It sets the property @var{opaque} to
be either 0, 1 or 2.  
@end deftypefn


@subsection The Note Class
The note class provides a handy way of communicating in MOO, whether you
want to leave somebody a quick message, or perhaps leave a clue for
solving an adventure.  The note class can also provide a good starting
base for more specialized objects.  The letter and newspaper objects are
examples of this.

@deftypefn Verb none r*ead ()
This verb first checks to see if the note can be read by the person who
is attempting to read the it.  If they have permission to read it, the
note text, which is stored in the property @code{text}, is shown to the
player.
@end deftypefn

@deftypefn Verb none er*ase ()
This verb erases all text stored on the note.  Only the owner of a note
can erase it.
@end deftypefn

@deftypefn Verb none wr*ite (string @var{message})
Appends the string @var{message} to the note text.  This function simply
adds another line to the list stored in the note property 'text'.  A
carriage return is inserted between each list entry, therefore the
command:

@example
write "Zaphod was here." on note
@end example

@noindent
would be read as

@example
Zaphod was here.
@end example
whereas the commands

@example
write "Zaphod" on note
write "was" on note
write "here." on note
@end example

would be read as

@example
Zaphod
was
here.
@end example

@end deftypefn

@deftypefn Verb none del*ete (string @var{line-number})
@deftypefnx Verb none rem*ove (string @var{line-number})
Deletes the given line number from the note.  Only the owner of the note
may modify it.  Negative numbers can be given to delete lines counting
from the end of the note, hence @samp{delete -5 from note} would delete
the 5th line from the bottom.
@end deftypefn
     
@deftypefn Verb list text ()
Returns a list of strings containing the message text on the note.
Called by the verb @code{:r*ead}.
@end deftypefn

@deftypefn Verb num is_readable_by (obj PLAYER)
This verb uses the @code{$lock_utils:eval_key} verb to evaluate the key,
stored in the @code{encryption_key} property, and determine if the note
is readable or not by the player.  This verb will return a @samp{1} if it is
readable, or a @samp{0} if it is not.
@end deftypefn

@deftypefn Verb none encrypt (string ENCRYPTION)
This verb will encrypt a message so that it can only be read if the
encryption constraints are satisfied. Refer to the @samp{@@lock} command
for details on the syntax for encryption. Encryption is stored in the
@code{encryption_key} property.  You must have permission to do this.
@end deftypefn

@deftypefn Verb none decrypt ()
This verb will remove any existing encryption from a note, allowing it
to be read by anybody.  You must have permission to do this.
@end deftypefn

The following properties are defined for the @code{$note} class.

@defvr Property encryption_key
This is encryption string for the note. It is formed within the verb
@code{:encrypt} by parsing its input with
@code{$lock_utils:parse_keyexp}.  The verb @code{:is_readable_by} then
uses this to determine whether or not the note can be read by calling
@code{$lock_utils:eval_key}.

@end defvr

@defvr Property text
This is a list of strings where the body of the note message is kept.
Each entry in the list corresponds to one line in the note text.
@end defvr

@subsection The Newspaper Class
To be written.

@subsection The Letter Class
The letter class is a subclass of the note class.  A letter object provides
all of the functions of a note, with the addition of a @samp{burn} command.
This command will recycle the note after it has been read by the recipient,
completely removing it from the database.  The letter is read, written,
erased and encrypted just as if it were simply a note object.

@deftypefn Verb none burn
This verb first checks to see if the letter is readable by the person
who is attempting to burn it.  If it is, the letter will be completely
destroyed.  If it is not readable, the command will fail.  The code for
this is shown below for illustration:

@example
if (this:is_readable_by(player))
  player:tell(this.name, 
         " might be damp, in any case it won't burn.");
else
  player:tell(this.name, 
      " burns with a smokeless flame, and leaves no ash.");
  player.location:announce(player.name, 
      " stares at ", this.name, " and it catches alight.");
  recycle(this);
endif
@end example

@end deftypefn

@subsection The Generic Programmer Class

@subsection The Help Database Class
The LambdaCore database provides an extensive help facility.   As well
as command syntax, it provides other useful information on a variety of
other MUD topics.  The @code{$help} class is used to store help text and
verbs used to implement the help system.  A verb on the player class,
@code{$player:help} is used to give the player access to the help
database.

Each entry in the help database is stored as a property on the
@code{$help} class.  By doing this, an index can be generated by using
the @code{properties()} primitive to list all the properties on
@code{$help}.   No other properties are stored on the @code{$help}
class.

The @samp{help} command, defined on the @code{$player} class, is
described below.

@deftypefn Verb none help 
@deftypefnx Verb none help @var{topic}
@deftypefnx Verb none help @strong{index}
This verb, part of the player class, is used to gain access to the help
system.   The first form is used to obtain help on the topic
@code{summary}, which is a top level help with pointers to other topics
in the database.

If the third form, @samp{help index} is used, the verb
@code{$help:print_index} is invoked to print a list of all the help
topics currently available.

The most complex case is the second form, where help is being requested
on a particular topic.   The relevant code segment is shown below:

@example
  topics = $help:find_topics(dobjstr);
  if (topics == @{@})
    player:tell("Sorry, but no help is available on \"",
          dobjstr, "\".");
    return;
  elseif (length(topics) > 1)
    player:tell("Sorry, but the topic-name \"", 
              dobjstr, "\" is ambiguous.", 
     " I don't know which of the following topics you mean:");
    for x in (topics)
      player:tell("   ", x);
    endfor
    return;
  else
    topic = topics[1];
    if (topic != dobjstr)
      player:tell("Showing help on \"", topic, "\" ...");
      player:tell();
    endif
  endif
  $help:print_topic(topic);
@end example

First, the verb @code{$help:find_topics} is called.  This takes the
@var{topic} given by the player, and searches through the help database
index for possible matches.  This returns a list of possible topics in
the variable @var{topics}.

If the list is empty, than no help was available for the topic given by
the player, and the verb ends.

If the list contains more than one item, the player is told what
matched, and asked to be more specific next time.

If just one help topic was found, it is printed out, using the verb
@code{$help:print_topic}. 
@end deftypefn

The @code{$help} class has three verbs defined on it which are used to
implement the help system.  They are described in detail below:

@deftypefn Verb list find_topics (string @var{handle})
This verb is used to search the list of topics on the @code{$help} class
for one that matches @var{handle}.  The list of topics is given by the
list of properties defined on the @code{$help} class.   In the simple
case, if the @var{handle} matches one property name exactly, then this
name is returned.

The player is allowed to omit the leading @samp{@@} on commands.  This
is checked for in this verb by adding an @samp{@@} temporarily, and then
checking for this in the topic list, along with the un-prefixed
@var{handle}.

If no direct match is found, the verb looks at all the properties stored
on the @code{$help} class, and tries to make a match using
@code{index()} between the @var{handle}, the @var{handle} with an
@samp{@@} prepended and all the property names.  Every possible match is
returned by this verb, so that the @samp{help} command can give the list
to the user.

If no matches are found, an empty list is returned.
@end deftypefn

@deftypefn Verb none print_index ()
This verb is used to print an alphabetical list of help topics, as given
by the properties stored on the @code{$help} class.  The code for this
function is shown below, as it illustrates one method of sorting strings
in MOO, using lists.

@example
topics = setremove(properties(this), "summary");
buckets = "abcdefghijklmnopqrstuvwxyz";
else_bucket = length(buckets) + 1;
counts = names = @{@};
for i in [1..else_bucket]
  names = @{@@names, @{""@}@};
  counts = @{@@counts, 1@};
endfor
keys = names;
count = 1;
for name in (topics)
  if (name && index(".@@", name[1]))
    key = name[2..length(name)];
  else
    key = name;
  endif
  k = index(buckets, key[1]) || else_bucket;
  bucket = keys[k];
  count = counts[k];
  i = 1;
  while (i <= count && key > bucket[i])
    i = i + 1;
  endwhile
  names = listset(names, listappend(names[k], name, i - 1), k);
  keys = listset(keys, listappend(keys[k], key, i - 1), k);
  counts = listset(counts, count + 1, k);
endfor
sorted = @{@};
for i in [1..length(names)]
  sorted = @{@@sorted, @@names[i][2..counts[i]]@};
endfor
sorted = @{@@sorted, "", "", ""@};
n = length(sorted) / 4;
su = $string_utils;
for i in [1..n]
  player:tell(su:left(sorted[i], 20), 
              su:left(sorted[i + n], 20), 
              su:left(sorted[i + n + n], 20), 
              sorted[i + 3 * n]);
endfor
@end example

@end deftypefn

@deftypefn Verb none print_topic (string @var{topic})
@end deftypefn

@section The LambdaCore Utility Classes

The following utility classes are provided in the LambdaCore database:

@display
@table @code
@item String Utils.  ($string_utils)
This class provides a number of verbs containing string utility
functions.

@item Building Utils.  ($building_utils)
This class provides a couple of verbs used in building commands.

@item Permissions Utils.  ($perm_utils)
This class provides verbs used in manipulating permissions on
objects.

@item Code Utils.  ($code_utils)
This class provides some useful general purpose verbs.

@item Command Utils.  ($command_utils)
This class provides some verbs used for command line parsing.

@item List Utilities.  ($list_utils)
This class provides a couple of verbs used in manipulating lists.

@item Matching Utils.  ($match_utils)
This class provides verbs used in matching names to objects.

@item Trignometric Utilities ($trig_utils)
This class provides some trigonometric functions and other mathematical
utilities.

@item Lock Utilities.  ($lock_utils)
This class provides verbs used in dealing with locks on objects.

@item Object Utilities.  ($object_utils)
This class provides some useful verbs used in manipulating objects.

@item Time Utilities ($time_utils)
This provide some time manipulation utilities.

@item Gender Utilities ($gender_utils)
These provide some gender based utilities.

@end table
@end display

@subsection The String Utilities Class
The string utilities class, @code{$string_utils} defines a number of
verbs useful for performing operations on strings.

@deftypefn Verb list explode (list @var{subject} [, str @var{break}])
This verb is used to explode a string into a list of substrings
separated by runs of @var{break} as the delimiting character. If
@var{break} is not specified it defaults to space. As an example:

@example
$string_utils:explode("This    is a   test");
@end example

@noindent
will return the list

@example
@{"This", "is", "a", "test"@}
@end example

@end deftypefn

@deftypefn Verb str from_list (list @var{list} [, str @var{separator}])
This verb is used to implode the string representations of the elements
of a list into a single string, each pair being separated by
@var{separator}.  which defaults to the empty string. This function is
essentially the inverse of @code{:explode}.  Note that the elements of
@var{list} need not be strings themselves, as the function @code{tostr}
is applied to each element before it is catenated. As an example, to
reassemble the list above into the original string, with just one space
between words, you could write:

@example
oldstr = $string_utils:from_list(@{"This", "is", "a", "test"@}, " ");
@end example
@end deftypefn

@deftypefn Verb object match (str @var{string} [, list @var{obj-list}, str @var{prop-name}]*)
This verb is used to search for a match to @var{string} in all the
specified properties of all the specified objects, returning either
object, @code{$ambiguous_match} or @code{$failed_match}.

Each @var{obj-list} should be a list of objects or a single object,
which is treated as if it were a list of that object.  Each
@var{prop-name} should be a string naming a property on every object in
the corresponding @var{obj-list}.  The value of that property in each
case should be either a string or a list of strings.

The argument string is matched against all of the strings in the
property values.

If it exactly matches exactly one of them, the object containing that
property is returned.  If it exactly matches more than one of them,
@code{$ambiguous_match} is returned.

If there are no exact matches, then partial matches are considered, ones
in which the given string is a prefix of some property string.  Again,
if exactly one match is found, the object with that property is
returned, and if there is more than one match, @code{$ambiguous_match}
is returned.

Finally, if there are no exact or partial matches, then
@code{$failed_match} is returned.

@end deftypefn

@deftypefn Verb str from_value (item @var{value} [, str @var{quote_strings} [, num @var{list_depth}]])
This verb is used to print the given value into a string. Note that
@var{quote_strings} defaults to 0 (false), and @code{list_depth}
defaults to 1.  This is best described by example:

@example
$string_utils:from_value(v) gives:

value result 5 "5" 5 + 3 "8" "5 + 3" "5 + 3" @{@} "@{@}" @{1,2,3@} "@{1,
2, 3@}" @{1, @{2, 3@}, 4@} "@{1, @{list@}, 4@}" @{"1", @{2, 3@}, 4@}
"@{1, @{list@}, 4@}"

$string_utils:from_value(value, 1) gives:

value                     result
5                     "5"
5 + 3                 "8"
"5 + 3"               "\"5 + 3\""
@{@}                    "@{@}"
@{1,2,3@}               "@{1, 2, 3@}"
@{1, @{2, 3@}, 4@}        "@{1, @{list@}, 4@}"
@{"1", @{2, 3@}, 4@}      "@{\"1\", @{list@}, 4@}"


$string_utils:from_value(value, 0, 2) gives:

value                     result
5                     "5"
5 + 3                 "8"
"5 + 3"               "5 + 3"
@{@}                    "@{@}"
@{1,2,3@}               "@{1, 2, 3@}"
@{1, @{2, 3@}, 4@}        "@{1, @{2, 3@}, 4@}"
@{"1", @{2, 3@}, 4@}      "@{1, @{2, 3@}, 4@}"

$string_utils:from_value( value, 1, 2 ) gives:

value                     result
5                     "5"
5 + 3                 "8"
"5 + 3"               "\"5 + 3\""
@{@}                    "@{@}"
@{1,2,3@}               "@{1, 2, 3@}"
@{1, @{2, 3@}, 4@}        "@{1, @{2, 3@}, 4@}"
@{"1", @{2, 3@}, 4@}      "@{\"1\", @{2, 3@}, 4@}"
@end example

It is interesting to note that @code{:from_value} calls itself
recursively, to evaluate lists.

@end deftypefn

@deftypefn Verb str pronoun_sub (str @var{text} [, obj @var{who}])
This verb is used to substitute the pronoun properties of @var{who} in
all occurances of %s,%o,%p,%r in @var{text}. @var{who} is optional, and
defaults to player. Also @samp{%n}, @samp{%d}, @samp{%i}, @samp{%t},
@samp{%%} are substituted by @code{player}, @code{dobj}, @code{iobj},
@code{this} and @code{%} respectively. Further, @samp{%(propname)} is
substituted by @code{@var{who}.propname}.  Capitalised versions of each
of these are: @samp{%S}, @samp{%O}, @samp{%P}, @samp{%R},
@samp{%N},@samp{%D}, @samp{%I}, @samp{%T} and @samp{%(Propname)}. The
full list is given below:

@example
Code       Property      Pronoun       Defaults
----       --------      -------       -------
%%                                    %
%s        @var{who}.ps      subjective    he, she, it
%S        @var{who}.psc     subjective    He, She, It
%o        @var{who}.po      objective     him, her, it
%O        @var{who}.poc     objective     Him, Her, It
%p        @var{who}.pp      possessive    his, her, its
%P        @var{who}.ppc     possessive    His, Her, Its
%r        @var{who}.pr      reflexive     himself, herself, itself
%R        @var{who}.prc     reflexive     Himself, Herself, Itself
%n        @var{who}.name
%N        @var{who}.name                  (capitalised)
%d        dobj.name
%D        dobj.name                 (capitalised)
%i        iobj.name
%I        iobj.name                 (capitalised)
%t        this.name
%T        this.name                 (capitalised)
%(xyz)    @var{who}.xyz
%(Xyz)    @var{who}.xyz                   (capitalised)
@end example

@end deftypefn

@deftypefn Verb str space (num @var{num} [, str @var{str}])
This verb returns a string of @var{num} occurences of @var{str}.
@var{str} is optional, and defaults to space (" ").

@example
:space(8)        returns   "        "
:space(8, "z")   returns   "zzzzzzzz"
:space(4, "<>")  returns   "<><><><>"
@end example

@end deftypefn

@deftypefn Verb str right (str @var{text}, num @var{len} [, str @var{fill}])
This verb is used to right justify @var{text} in a string of length
@var{len}.  @var{fill} is the optional fill character, which defaults to
space. This function calls @code{$string_utils:space} (described above).
It is interesting to note that text need not be a string, as
@code{tostr()} is applied to it before justification.

@example
:right("help", 9)      returns   "     help"
:right("me", 9, ".")   returns   ".......me"
:right(200, 9, "*")    returns   "******200"
:right(@{1,2@}, 9)       returns   "   @{list@}"
@end example

@end deftypefn

@deftypefn Verb str centre (str @var{text}, num @var{len} [, str @var{fill}])
This verb (aka @code{$string_utils:center}) is used to centre @var{text}
in a string of length @var{len}. @var{fill} is the optional fill
character, which defaults to space.  This function calls
@code{$string_utils:space}, (described above).

@example
:centre("help", 9)      returns   "  help   "
:centre("me", 9, ".")   returns   "...me...."
:centre(200, 9, "*")    returns   "***200***"
:centre(@{1,2@}, 9)       returns   " @{list@}  "
@end example

@end deftypefn

@deftypefn Verb str left (str @var{text}, num @var{len} [, str @var{fill}])
This verb is used to left justify @var{text} in a string of length
@var{len}.  @var{fill} is the optional fill character, which defaults to
space. This function calls @code{$string_utils:space}, (described
above).  It is interesting to note that text need not be a string, as
@code{tostr()} is applied to it before justification.

@example
:left("help", 9)      returns   "help     "
:left("me", 9, ".")   returns   "me......."
:left(200, 9, "*")    returns   "200******"
:left(@{1,2@}, 9)       returns   "@{list@}   "
@end example

@end deftypefn

@deftypefn Verb str english_list (list @var{list} [str @var{empty} str @var{and} str @var{sep} str @var{penum}])
This verb is used to return a list of things as an english sentence.
Note that @code{tostr()} is applied, so things in the list need not
necessarily be strings.

The optional arguments allow you to control how the list is presented.
@var{empty} is the string returned if the list is empty.  The default is
@samp{nothing}.  @var{and} is the string to use instead of
@samp{ and } in the list.  A common usage of this is
replace @samp{ and } with @samp{ or }.
@var{sep} is the separator to use between words, the default being
@samp{ ,}.  Finally, @var{penum} is the string to use after the
penultimate elements, before the @samp{and}.  The default is to have a
comma without a space.

@example
:english_list(@{@})                         =  "nothing"
:english_list(@{"cat"@})                    =  "cat"
:english_list(@{"cat","dog"@})              =  "cat and dog"
:english_list(@{"cat","dog","pig"@})        =  "cat, dog, and pig"
:english_list(@{1@})                        =  "1"
:english_list(@{@{1, 2, 3@}, "Hi", 300@})     =  "@{list@}, Hi, and 300"
@end example

@end deftypefn

@deftypefn Verb str from_seconds (num @var{secs})
This verb is used to return a string showing time in units of days,
hours, minutes or seconds.

@example
:from_seconds(0)        returns  "0 seconds"
:from_seconds(2)        returns  "2 seconds"
:from_seconds(61)       returns  "a minute"
:from_seconds(130)      returns  "2 minutes"
:from_seconds(7000)     returns  "an hour"
:from_seconds(1000000)  returns  "11 days"
@end example

@end deftypefn

@deftypefn Verb num find_prefix (str @var{subject}, list @var{choices})
This verb is used to find a string from a list of @var{choices} which
has the prefix @var{subject}.

For example, if choices = @{"hat", "hand", "face", "help"@} then...

@example
:find_prefix("f",  choices)  ==  3  
:find_prefix("g",  choices)  ==  0
:find_prefix("h",  choices)  ==  $ambiguous_match
:find_prefix("he", choices)  ==  4
:find_prefix("ha", choices)  ==  $ambiguous_match
@end example

@end deftypefn

@deftypefn Verb str trim (str @var{text} [, str @var{what}])
This verb is used to trim leading and trailing characters from the
string @var{text}. @var{what} is the optional character to trim, and
defaults to space.

@example
:trim("help")             returns  "help"
:trim("   help   ")       returns  "help"
:trim(">> help <<", ">")  returns  " help <<"
@end example

@end deftypefn

@deftypefn Verb str capitalise (str @var{text})
@deftypefnx Verb str capitalize (str @var{text})
@deftypefnx Verb str cap_fast (str @var{text})
This verb is used to capitalise its argument. Note that it depends on
@code{strcmp()} returning the difference of the first non-matching
letters!

@example
:cap_fast("hello")     returns    "Hello"
:cap_fast("Ezeke")     returns    "Ezeke"
@end example
   
@end deftypefn

@deftypefn Verb str strip_chars (str @var{subject}, str @var{stripped})
This verb is used to remove the characters in the string @var{stripped} from
the string @var{subject}.

@example
:strip_chars("The quick brown fox", " ")      =  "Thequickbrownfox"
:strip_chars("The quick brown fox", "aeiou")  =  "Th qck brwn fx"
@end example

@end deftypefn

@deftypefn Verb list match_player (str @var{name}, @dots{}, [obj @var{meobj})
@deftypefnx Verb obj match_player (str @var{name}, obj @var{meobj})
This verb is used to match one or more @var{name}s to player objects in
the database.  Note that @var{name} need not be complete, nor in the
same case as the player's actual name. If the @var{name} given is
@samp{me}, then the value of @code{player}, or @var{meobj} is returned.
If @var{meobj} is not a player, then @code{$failed_match} is returned.

In the case where a name is not matched against a player name or alias,
the value @code{$failed_match} is returned.  If a name matches more than
one player, then the value @code{$ambiguous_match} is returned.

For example:

@example
Verb Call                               Returned
---------                               --------
:match_player("blip")                   #35
:match_player("bli")                    #35
:match_player("blip", "Fred")           @{#35, $failed_match@}
:match_player("blip", "Ezeke")          @{#35, #99@}
:match_player("me", #35)                #35
:match_player("me", #1234)              $failed_match
:match_player("b")                      $ambiguous_match
@end example

@noindent
This assumes that players named @samp{blip} and @samp{Ezeke} exist in
the database, but @samp{Fred} doesn't.  Additionally, there is more than
one player whose name starts with @samp{b}.
@end deftypefn

@deftypefn Verb list words (str @var{text})
This verb is used to split a piece of @var{text} into words, in the same
wat that the command line parser turns @code{args} into @code{argstr}.
This verb differs from using, for example, @code{$string_utils:explode}
in that it recognises a quoted piece of text as being one word.  For
example:

@example
Verb Call                               Returned
---------                               --------
:words ("There is a dog.")              @{"There", "is", "a", "dog."@}
:words ("A \"red nose\"")               @{"A", "red nose"@}
:words ("")                             @{@}
:words ("Hello")                        @{"Hello"@}
@end example
@end deftypefn

@deftypefn Verb str cap_property (obj @var{what}, str @var{prop}, [, num @var{ucase}]))
This verb returns @var{what}.@var{prop}, but capitalised if either
@var{ucase} is true, or the property name specified is capitalised.  If
@var{prop} is blank, the verb returns the value of
@code{@var{what}:title()}.  If @var{prop} is not specified on @var{what}
or is otherwise irretrievable, then an error is returned. 

If capitalisation is indicated by @var{ucase} being true, we return
@code{@var{what}.@var{prop}c} if that exists, otherwise
@var{what}.@var{prop} is capitalised in the normal fashion using
@code{$string_utils:capitalise}.  A special case exists if we are trying
to retrieve the name of a player.  This is never capitalised.
@end deftypefn

@deftypefn Verb num index_delimited (str @var{string}, str @var{target} [, num @var{casem}])
This verb works in the same way as the primitive @code{index()}, except
that it only matches on occurrences of @var{target} in @var{string} that
are delimited by word boundaries.  That is, it will not match on
occurrences that are preceded or followed by an alphanumeric.

For example,

@example
Verb Call                                   Returned
---------                                   --------
:index_delimited ("Hi there", "he")            0
:index_delimited ("Hi there", "hi")            1
:index_delimited ("Hi there", "hi", 1)         0
:index_delimited ("Hi there", "Hi", 1)         1
@end example
@end deftypefn

@deftypefn Verb num to_value (str @var{expr})
This verb is used to convert a string into a value.  It is the opposite
operation to @code{$string_utils:from_value}.  As with that verb, this
is best explained by examples:

@example
$string_utils:to_value(s) gives:

s                               result
"5"                             5
"5 + 3"                         "5 + 3"
@{@}                              @error{}
@{1,2,3@}                         @error{}
"@{1,2,3@}"                       @{1,2,3@}                        
@end example
@end deftypefn

@deftypefn Verb list columnize columnise (list @var{items}, num @var{n} [, num @var{width}])
This verb is used to turn a one-column list of items into an @var{n} column
list. @var{width} is the last character position that may be occupied; it
defaults to a standard screen width of 79 characters.

For example, to tell a player a list of number in three columns, use the
following code:

@example
player:tell_lines($string:utils:columnise (@{1, 2, 3, 4, 5, 6, 7@}, 3));
@end example
@end deftypefn

@deftypefn Verb list parse_command (str @var{command}, @var{who})
This verb is used to parse a command line, in the same way that the
built in command line parser does the job.  It returns an horrendous
list of stuff, that I'm not quite sure about yet.
@end deftypefn

@deftypefn Verb list match_str*ing (str @var{input}, str @var{match}, @dots{})
This verb performs wildcard matching of @samp{match} to @var{input},
using the @samp{*} character as a wildcard.  It returns a list of what
the @code{*}s actually matched.  Note that this verb will not catch
every match, if there are several different ways to parse the input.
More than one wildcard string may be given.  If a numeric argument is
given, it is taken to indicate whether case sensitivity should be used.

For example:

@example
;$string_utils:match_string(\"Jack waves to Jill\",\"* waves to *\")
@print{}@{\"Jack\", \"Jill\"@}
@end example
@end deftypefn

@deftypefn Verb str uppercase lowercase (str @var{string})
This verb returns either the uppercase or lowercase version of
@var{string}, as appropriate.
@end deftypefn

No properties are defined on the @code{$string_utils} class.

@subsection The Permissions Utils Class
The permission utilities class, @code{$perm_utils} provides a couple of
useful verbs for dealing with permissions of objects, i.e.. the ability of
a player to read or access another object.

@deftypefn Verb num controls (obj @var{who}, obj @var{what})
Returns true, @samp{1}, if @var{who} is the owner of @var{what}, or if
@var{who} is a @emph{wizard}, else returns false, @samp{0}.
@end deftypefn

@deftypefn Verb str apply (str @var{perms}, str @var{mods})
This verb is used to modify the permissions given in @var{perms} with
the modifiers shown in @var{mods}.  The following modifiers are
possible:

@display
@table @code
@item !
- negate a permission.
@item +
- add a permission.
@item -
- remove a permission.
@end table
@end display

Consider the following examples:

@example
Verb Call                          Returns
---------                          -------
;$perm_utils:apply("rw", "!w")     "r"
;$perm_utils:apply("rw", "!r")     "w"
;$perm_utils:apply("rw", "-w")     "r"
;$perm_utils:apply("rw", "")       ""
;$perm_utils:apply("rw", "x")      "x"
;$perm_utils:apply("rw", "+x")     "rwx"
@end example
@end deftypefn

No properties are defined on the @code{$perm_utils} class.

@subsection The Code Utils Class

The code utils class is somewhere to hang code functions. These are
defined as verbs of the @code{$code_utils} class.

@deftypefn Verb list parse_propref (str @var{string})
This function parses @var{string} as a MOO-code property reference,
returning

@example
@{@var{object-string}, @var{prop-name-string}@}
@end example

@noindent
for a successful parse and false otherwise. It always returns the right
object-string to pass to, for example, @code{$room:match_object()}.

The following examples show how this verb works:

@example
:parse_propref("me")               returns   0
:parse_propref("me.name")          returns   @{"me", "name"@}
:parse_propref("$room.location")   returns   @{"#3", "location"@}
:parse_propref("$thing")           returns   @{"#0", "thing"@}
:parse_propref("$player:tell")     returns   0
@end example

@end deftypefn

@deftypefn Verb list parse_verbref (str @var{string})
This function parses @var{string} as a MOO-code verb reference, returning

@example
@{@var{object-string}, @var{verb-name-string}@}
@end example

@noindent
for a successful parse and false otherwise. It always returns the right
object-string to pass to, for example, @code{$room:match_object()}.

The following examples show how this verb works:

@example
:parse_verbref("me")              returns   0
:parse_verbref("me:title")        returns   @{"me", "title"@}
:parse_verbref("$room:blow_up")   returns   @{"#3", "blow_up"@}
:parse_verbref("$thing")          returns   0
:parse_verbref("player:tell")     returns   @{"player", "tell"@}
@end example
@end deftypefn

@deftypefn Verb none show_object (obj @var{obj})
@deftypefnx Verb none show_property (obj @var{obj}, str @var{pname})
@deftypefnx Verb none show_verbdef (obj @var{obj}, str @var{vname})
These verbs are the ones used by the @samp{@@show} command to display
details of an object, a property on an object, or a verb on an object.
Below is some sample code used to display details on the paranoid
property of ezeke:

@example
fullpropref = "ezeke.paranoid";
here = player.location;
prop = $code_utils:parse_propref(fullpropref);
if (!prop)
  player:tell("Could not parse string.");
else
  obj = here:match(prop[1]);
  if (obj < #0)
    player:tell("Could not match '", prop[1], "'.");
  else
    $code_utils:show_property(obj, prop[2]);
  endif
endif
@end example
@end deftypefn

@deftypefn Verb none find_verbs_containing (str @var{pattern}, num @var{start_obj}, num @var{count})
This verb prints to the player the name and owner of every verb in the
database whose code contains @var{pattern} as a substring.  It starts at
the object number @var{start_obj} (as a number, not an object) and goes
to the end of the database.  @var{count} specifies how many verbs have
been found so far.  Because it searches the entire database, this
function may not be finished when it returns; it may have forked a task
to continue the job.

For example:
@example
>;$code_utils:find_verbs_containing ("show_property", 0, 0)
@print{}#4:@@s*how, line 18 [Wizard (#2)]
@end example
@end deftypefn

@subsection The Command Utilities Class
The command utilities class, @code{$command_utils} provides a couple of
useful verbs for dealing with player commands, as follows:

@deftypefn Verb num object_match_failed (obj @var{result}, str @var{string})
This function tells the player of a failed match, and returns true if so.
If @var{result} is valid it returns false, without telling the player
anything. For example, (where @code{#118} has been recycled):

@example
Result            String  Ret  Player sees...
------            ------  ---  --------------
$failed_match     "blip"   1   I see no "blip" here.
$ambiguous_match  "blip"   1   I don't know which "blip" you mean.
#118              ""       1   #118 does not exist.
#28               "blip"   0
@end example

@noindent
This could be used in the following way, in the implementation of a 'bop'
command, defined as a verb on a player:

@example
/* bop <any> */
here = player.location;
victim = here:match(dobjstr);
if (!$command_utils:object_match_failed(victim, dobjstr))
  player:tell("You bop ", dobj.name, " over the head!");
  dobj:tell(player.name, " bops you over the head!");
  here:announce_all_but(@{player,dobj@}, 
  player.name + " bops " + dobj.name + " over the head!");
endif
@end example

@end deftypefn

@deftypefn Verb none player_match_result (list @var{results}, list @var{strings}, [str @var{prefix}])
This verb is used to inform the player of the results of trying to match
the player names in @var{string} with players in the database.  It
assumes that @var{results} are the result of a
@code{$string_utils:match_player(strings)} and prints out nasty messages
to the player concerning @var{strings} that didn't match with any player
in teh database.  It returns a list, in the following format:

@example
@{@var{our_result}, @var{player1}, @dots{}, @var{playerN}@}
@end example

@noindent
where @var{our_result} is an overall result, set to @samp{true} if some
string didn't match, followed by the object reference numbers of players
that matched.  An optional third argument, @var{prefix}, gives an
identifying string to prefix to each of the nasty messages.

For example, supposing there are only players named @samp{blip} and
@samp{blipster} in the database:

@example
Results            Strings     Ret      Player Sees....
-------            -------     ---      ---------------
@{$nothing@}         @{"George"@}  0        @emph{nothing}
@{$failed_match@}    @{"George"@}  1        "George" is not the 
                                            name of any player.
@{$ambiguous_match@} @{"blip"@}    1        "blip" could refer to any
                                            of a number of people."
@{#28@}              @{"blip"@}    @{0, #28@} @emph{nothing}
@end example

@noindent
The following code fragment from @code{$player:page} shows how you might
use this function in your own programs:

@example
who = $string_utils:match_player(args[1]);
if ($command_utils:player_match_result(who, args[1])[1])
  return;
@end example

@noindent
The variable @var{args[1]} contains the name of the player we are trying
to page
@end deftypefn

@noindent
No properties are defined on the @code{$command_utils} class.

@subsection The List Utilities Class

The list utilities class, @code{$list_utils} defines a number of
functions that manipulate lists.  

@deftypefn Verb list map_prop (list @var{objs}, string @var{prop})
This function returns a list of the values of a specified property
@var{prop} on each of the objects in the list @var{objs}. If @var{prop}
does not exist on one of the objects, an error occurs.

As an example, the following code will list all the locations that have
at least one player in them. It uses the @code{:map_prop} verb to
generate a list corresponding to each player's location. Set addition is
used to provide a list of the location names without duplication. Note
that the @code{players()} primitive returns a list of all the player
objects in the database.

@example
locs = $list_utils:map_prop(players(), "location");
rooms = @{@};
for x in (locs)
  rooms = setadd(rooms, x.name);
endfor
player:tell("Inhabited locations are ", 
             $string_utils:english_list(rooms), ".");
@end example
@end deftypefn

@deftypefn Verb list map_verb (list @var{objs}, string @var{verb} [, list @var{varg}])
This function returns a list of the return values of a specified verb
@var{verb} on each of the objects in the list @var{objs}. @var{varg} is
optional and defines the arguments to @var{verb}; it defaults to the
empty list @{@}. If @var{verb} does not exist on one of the objects, an
error occurs.

As an example, the following code will list all the connected players,
using the @code{:title} verb on each to do so. It uses the
@code{:map_verb} function to generate a list of each of the player's
@dfn{title strings}.

@example
cp = $list_utils:map_verb(connected_players(), "title");
player:tell("Connected players are ", 
              $string_utils:english_list(cp), ".");
@end example

@end deftypefn

@deftypefn Verb list assoc (@var{target}, list @var{list}, [num @var{index}])
This verb requires @var{list} to be a list of lists. It returns the
first element of @var{list} whose own @var{index}th element is
@var{target}.  If not supplied, @var{index} defaults to @samp{1}.

Consider the following examples:

@example
Verb Call                        Returned
---------                        --------
:assoc(1, @{@{2,3@}, @{1, 2@}@})       @{1,2@}
:assoc(1, @{@{2,3@}, @{2, 1@}@})       @{@}
:assoc(1, @{@})                    @{@}
@end example

@noindent
Consider a more interesting example.  Suppose that you have a list of
heights for a number of players, in the following format:

@example
@{@{@var{name1}, @var{height1}@}, @dots{}, @{@var{nameN}, @var{heightN}@}@}
@end example 

@noindent
and you want to search through the list to find out how tall a
particular player is.  This can be done using the following code,
assuming that the variable @var{heights} is the list of
@samp{@{@var{name}, @var{height}@}} pairs, and @var{ourplayer} is
the player whose height you wish to look up:

@example
player:tell(ourplayer, "is ", 
    $list_utils:assoc (ourplayer, heights)[2], "ft high");
@end example

@noindent
Suppose that @var{heights} is defined as follows:

@example
@{@{"blip", 2@}, @{"Ezeke", 6@}, @{"Geezer", 10@}@}
@end example

@noindent 
For different lookups, we would get the following results:

@example
ourplayer                   Results
blip                        @{"blip", 2@}
Ezeke                       @{"Ezeke", 6@}
Fred                        @{@}
@end example
@end deftypefn

@deftypefn Verb num iassoc (@var{target}, list @var{list}, [num @var{index}])
This verb works similarly to @code{$string_utils:assoc} except that it
returns an index into @var{list}, rather than the actual matching
element from @var{list}.  If no matching element is found, it returns
@samp{0}.
Consider the following examples:

@example
Verb Call                        Returned
---------                        --------
:assoc(1, @{@{2,3@}, @{1, 2@}@})       2
:assoc(1, @{@{2,3@}, @{2, 1@}@})       0
:assoc(1, @{@})                    0
@end example
@end deftypefn

@deftypefn Verb list sort_alist (list @var{list}, [num @var{index}])
This verb requires @var{list} to be a list of lists. It sorts the
@var{list} into ascending order, using the @var{index}th element of each
list element as the sort key.  For example:

@example
Verb Call                         Returned
---------                         --------
sort_alist(@{@{5@}, @{2@}, @{3@}@})       @{@{2@}, @{3@}, @{5@}@}
sort_alist(@{@})                    @{@}
sort_alist(@{@{2,3@},@{5,1@},@{3,6@}@},2) @{@{5,1@},@{2,3@},@{3,6@}@}  
@end example
@end deftypefn

@deftypefn Verb list map_pronoun_sub (list @var{objects}, @var{string})
This verb returns the result of calling @code{$string_utils:pronoun_sub}
for each object in the list @var{objects} on the @var{string} supplied.
For example, where @samp{#28} is named @samp{blip}, and @samp{#35} is
named Ezeke:

@example
our_objs=@{#28,#35@};
our_msg="Hello %n";
our_output=$list_utils:map_pronoun_sub(our_objs, our_msg);
player:tell_lines (our_output);
@end example

@noindent
Executing this short program would produce the following output

@example
>run_test_program
@print{}Hello blip.
@print{}Hello Ezeke.
@end example
@end deftypefn

@deftypefn Verb list slice (list @var{list}, [num @var{index}])
This verb returns a list of the @var{index}th elements of the elements
of @var{list}.  If @var{index} is not given, it defaults to @samp{1}.
For example,

@example
Verb Call                          Returns
---------                          -------
:slice (@{@{1,2@}, @{3,4@}, @{5,6@}@}@})    @{1,3,5@}
:slice (@{@{1,2@}, @{3,4@}, @{5,6@}@}@},2)  @{2,4,6@}
:slice (@{@}@}                        @{@}
@end example
@end deftypefn

@noindent
No properties are defined on the @code{$list_utils} class.

@subsection The Building Utils Class

This class provides a couple of utility functions used in building rooms
and exits in the core database structure.  The verbs provided are used
mainly by the building command @samp{@@dig}, although they can, of
course, be used by other verbs.

@deftypefn Verb none set_names (obj @var{object}, string @var{spec})
The function is used to set both the name of an object and any aliases
that the programmer needs.  It expects 2 arguments: first, the object
reference whose name is to be set, and then a string which contains the
name and any aliases as a comma delimited string.
@end deftypefn

@deftypefn Verb none make_exit (string @var{spec}, obj @var{source}, obj @var{dest})
This is a function that is used to create a named exit with given source
and destination rooms.  The code will do a protection check to verify
that an exit can be created and which if any links specified can be
made.

The following will try to create an exit called @samp{Out} owned by the
calling player and then link that exit to #25 as the source (exit from)
and #26 as the destination (entrance to).

@example
$building_utils:make_exit("Out", #25, #26);
@end example
@end deftypefn

@subsection The Lock Utilities Class
This class provides some useful functions related to the use of
@dfn{locks} for objects in the database. The LambdaCore database
supports a simple but powerful notation for specifying locks on objects,
encryption on notes, and other applications.  The idea is to describe a
constraint that must be satisfied concerning what some object must be or
contain in order to use some other object.

The constraint is given in the form of a logical expression, made up of
object numbers connected with the operators @samp{and}, @samp{or}, and
@samp{not} (written @samp{&&}, @samp{||}, and @samp{!}, for
compatibility with the MOO programming language).

These logical expressions (called @dfn{key expressions}) are always
evaluated in the context of some particular @dfn{candidate} object, to see
if that object meets the constraint.  To do so, we consider the
candidate object, along with every object it contains (and the ones
those objects contain, and so on), to be @samp{true} and all other objects to
be @samp{false}.

As an example, suppose the player blip wanted to lock the exit leading
to his home so that only he and the holder of his magic wand could use
it.  Further, suppose that blip was object #999 and the wand was #1001.
blip would use the '@@lock' command to lock the exit with the following
key expression:

@example
me || magic wand
@end example

@noindent
and the system would understand this to mean

@example
#999 || #1001
@end example

That is, players could only use the exit if they were (or were carrying)
either #999 or #1001.

There is one other kind of clause that can appear in a key expression:

@example
? @var{object}
@end example

This is evaluated by testing whether the given object is unlocked for
the candidate object; if so, this clause is true, and otherwise, it is
false.  This allows you to have several locks all sharing some single
other one; when the other one is changed, all of the locks change their
behavior simultaneously.

The internal representation of key expressions is stored in the property
@code{.key} on every object.

@subsubsection Key Representation For Locks
Objects are represented by their object numbers and all other kinds of
key expressions are represented by lists.  These lists have as their
first element a string drawn from the following set:

@example
"&&"     "||"     "!"     "?"
@end example

@noindent
For the first two of these, the list should be three elements long; the
second and third elements are the representations of the key expressions
on the left- and right-hand sides of the appropriate operator.  In the
third case, @samp{!}, the list should be two elements long; the second
element is again a representation of the operand.  Finally, in the @samp{?}
case, the list is also two elements long but the second element must be
an object number.

As an example, the key expression

@example
#45  &&  ?#46  &&  (#47  ||  !#48)
@end example
@noindent
would be represented as follows:

@example
@{"&&", @{"&&", #45, @{"?", #46@}@}, @{"||", #47, @{"!", #48@}@}@}
@end example

@subsection Verbs for Manipulating Locks and Keys
The following utility verbs, defined on the @code{$lock_utils} class can
be used by the programmer to manipulate locks on objects and key
expressions.

@deftypefn Verb num eval_key (list @var{key}, obj @var{who})
This verb evaluates the key expression @var{key}, in the context of the
candidate object @var{who}.  It returns @samp{1} if the @var{key} will
allow @var{who} to pass, otherwise it returns @samp{0}. The simple
examples below are intended to show the ways in which this verb can be
invoked:

@example
Verb Call                     Returned
---------                     --------
:eval_key(#35, #35)              1
:eval_key(@{"!", #35@}, #35)       0
:eval_key(@{"!", #35@}, #123)      1
@end example

The @var{key} expression is given as a list, in the format described
above.
@end deftypefn

@deftypefn Verb list parse_keyexp (string@var{keyexp}, obj @var{who})
This verb parses the string @var{keyexp} and returns the internal
representation of the expression, for use with
@code{$lock_utils:eval_key}.  It is used, for example, by the verb
@code{$player:@@lock} to parse the text given by a player into a key
expression to store on the @code{.key} property of an object.
@end deftypefn

@deftypefn Verb none init_scanner ()
@deftypefnx Verb none scan_token ()
@deftypefnx Verb none match_object ()
@deftypefnx Verb none canonicalize_spaces ()
@deftypefnx Verb none parse_E ()
@deftypefnx Verb none parse_A ()
These verbs are used by the verb @code{$lock_utils:parse_keyexp} to
perform it's parsing functions.  They can be called from user programs,
but are really part of the @code{:parse_keyexp} verb.
@end deftypefn

@deftypefn Verb string unparse_key (list @var{keyexp})
This verb takes the key expression @var{keyexp} and returns the input
expression that could be used to obtain that key.  It is the reverse
operation to @code{$lock_utils:parse_keyexp}.
@end deftypefn

A few properties are defined on the @code{$lock_utils} class, but these
are only used internally by the lock evaluation routines, and are of no
real interest to the programmer.

@subsection The Object Utilities Class
This class provides some utilities used to ascertain information about
objects.

@deftypefn Verb num contains (obj @var{container}, @var{target})
This verb returns `1' if @var{target} is in any way contained by
@var{container}.  This includes being directly in the contents list of
the object, and also in the contents list of any object that is
contained by @var{container}.  This verb is a partner to the
@code{:match} verb, as they both embody the same concept.
@end deftypefn

@deftypefn Verb list all_properties (obj @var{object})
This verb returns a list of names of all the properties of @var{object}.
This includes properties defined on the parent(s) of this object.
Recall that properties defined on the parent(s) of an object do not
appear in the set given by the @code{properties(@var{thing})} primitive
in MOO.  The @code{:all_properties} verb is useful for seeing the
properties that an object actually has values for.
@end deftypefn

@deftypefn Verb list all_verbs (obj @var{object})
Returns a list of all the names of the verbs defined for @var{object}.
This includes verbs defined on the parent(s) of this object.  Again, as
for the @code{:all_properties} verb, @code{:list_all_verbs} provides
the complete list of verbs that define an object's behaviour.  Using the
@code{verbs(@var{thing})} primitive in MOO lists only those verbs
actually @dfn{defined} on @var{thing}.
@end deftypefn

@deftypefn Verb list ancestors (obj @var{object})
This verb returns a list of the parent objects of this object.  This is
all the objects that lie above this object in the hierarchy.  All
objects have the @code{$root_class} in their list of parents.  For
example, the @code{$newspaper} class object has the @code{$note} class,
the @code{$thing} class and the @code{$root_class} as it's parents.

This verb can be used by an object to tell if another object is
descended from the same ancestor class.  Consider, for example, a
@code{generic zapper} object.  This is an object which can be used to
@code{shoot} at other people, with amusing and sometimes unexpected
results.  Bearing in mind that it is unfair to try and @code{zap}
someone who is unarmed, the verb @code{zapper:shoot} looks at the
possessions of the victim, and decides whether s/he is armed. If this is
the case, then the victim is fair game and deserves all s/he gets.  If
not, the zapper refuses to shoot, with embarrassing results for the
aggressive attacker.

Considering the implementation of the @code{zapper:shoot} verb, we could
determine if the victim has a zapper by comparing the @code{parent}s of
the assailant's zapper and each of the victim's possessions.  However,
this would only work if the zappers were first generation children of
the same parent - the @code{generic zapper} class.

Suppose, however, that the crafty player has built a @code{super zapper} class,
with radar sights, based on the @code{generic zapper} class.  In this
case, the test fails because the children of the @code{super zapper}
class are not first generation descendants of the original @code{generic
zapper} class.

A better way to code this test is to look at the @code{:ancestors} of
the objects, and see if the @code{generic zapper} class is numbered
amongst them.  If this is the case, then we can definitely know who is
armed and who isn't.
@end deftypefn

@deftypefn Verb list descendants (obj @var{object})
Returns a list of all this object's descendants, going down the object
hierarchy.
@end deftypefn

@deftypefn Verb obj has_verb (obj @var{object} string @var{vname})
This verb returns the object number of @var{object} if it defines the
verb @var{vname}.  If @var{object} does not define @var{vname}, then the
object number of any ancestor of @var{object} that does define the verb
is returned.  If the verb is not defined on @var{object} or any of it's
ancestors, then @samp{0} is returned.
@end deftypefn

@deftypefn Verb obj has_property (obj @var{object} string @var{pname})
This vernb returns @samp{1} if @var{object} has a property @var{pname},
else it returns @samp{0}.
@end deftypefn

@subsection The Matching Utilities
The matching utilities class, @code{$match_utils} provides several
useful verbs for matching strings to objects.   The following facilities
are provided:

@deftypefn Verb obj match (str @var{string}, list @var{where})
This is a general purpose matching verb.  It tries to match @var{string}
against the list of objects in @var{where}, if @var{string} does not
match any of the special cases, listed below.

@display
@table @code
@item me
This matches with the value of the @code{player} variable, i.e. the
player who is running the verb.
@item here
This returns the value of the @code{player.location} property.
@item ""
If a @code{null} argument is supplied, this verb returns the value of
the @code{caller} variable.
@item $@var{class}
This returns the value of the corresponding property on the system
object, @code{#0}.  This is used to match with, for example,
@code{$player}, @code{$exit} etc.  
@item #@var{num}
This returns the value of @var{num} as an object reference, as long as
the object referred to is valid, and meets one of the following
conditions:
@itemize @bullet
@item
The object is in the object that called this verb.
@item
The object is in the same location as the player.
@item
The object is being carried by the player.
@item
The object is in the same location as the caller.
@item
The object is owned by the player.
@end itemize
@item @var{string}
In the general case, a match is attempted using the
@code{$string_utils:match} verb, using the value of @var{where} as the
list of objects to match against.  The @code{aliases} property is used
to match the string against.
@end table
@end display

If no match is found using the above rules, a more general algorithm is
used.  This recognises forms such as the following:

@display
@table @code
@item @var{person}'s @var{object}
This matches against the item @var{object} in the inventory of
@var{person}.  The special case where @var{person} is specified by using
@samp{my} is catered for.  Note that @code{$match_utils:match} is used
to match the @var{person} string.
@item @var{number} @var{object}
This form allows you to specify a particular object in situations where
the @var{object} string would match more than one item.  The string
@var{number} is something like @samp{first}, @samp{second}, @dots{} or
@samp{1st}, @samp{2nd}, @dots{}.
@end table
@end display

These two forms can be combined, as show in the examples below.  Here we
assume that wizard(@code{#2}) is carrying two newspapers, with object
numbers @code{#10} and @code{#23}.  Wizard is currently standing in a
room with object reference @code{#11}.  The verb calls are made by the
Wizard, so that referring to @samp{me} or @samp{my} refers to the wizard.

@example
Verb Call                                   Returns
---------                                   -------
:match ("me", @{@})                              #2
:match ("here", @{@})                            #11
:match ("", @{@})                                $nothing
:match ("$player", @{@})                         #4
:match ("wizard", @{@})                          $failed_match
:match ("wizard", @{#2@})                        #2
:match ("my newspaper", @{@})                    #10
:match ("wizard's newspaper", @{@})              $failed_match
:match ("wizard's newspaper", @{#2@})            $ambiguous_match
:match ("wizard's first newspaper", @{#2@})      #10
:match ("wizard's second newspaper", @{#2@})     #23
:match ("first newspaper", @{#2@})               $failed_match
:match ("first newspaper", @{#10, #23@})         #10
:match ("second newspaper", @{#10, #23@})        #23
@end example
@end deftypefn

@deftypefn Verb obj match_nth (str @var{string}, list @var{where}, num @var{n})
This verb is used to match the @var{n}th occurrence of @var{string} in
the list of objects given in @var{where}.  This verb is used, for
example, by @code{$match_utils:match} to pick out one particular object
from a list with more than one possible match.

This verb looks at the @code{aliases} property of each of the objects in
the @var{where} list, and returns the @var{n}th match.  If there is no
@var{n}th match, then @code{$failed_match} is returned.  The idea behind
this verb is to allow you to specify particular objects in situations
where a normal match would return @var{$ambiguous_match}.  This verb
uses @code{index()} to do it's matching, and so returns objects which
partially match @var{string}.
@end deftypefn

@deftypefn Verb num match_verb (str @var{verb}, obj @var{what}, @var{args})
This verb returns @samp{1} if @var{verb} is found on the object
@var{what}.  The code for this is shown below:

@example
vrb = args[1];
what = args[2];
ret = what:(vrb)(args[3]);
return ret != E_VERBNF;
@end example

@noindent
Note that the verb being matched is executed with the @var{args} given,
but the result returned by the verb is lost.  If the verb is not found,
then @samp{0} is returned.
@end deftypefn

@deftypefn Verb list match_list (str @var{string}, list @var{where})
This verb returns a list of objects taken from the list @var{where} that
match with @var{string}.  The @code{aliases} property of each object is
checked to see if it can be matched against @var{string}.  If it can,
then it is added to the returned list.  This verb is used in cases where
you wish to know all the objects that match a particular @var{string}.
This verb uses @code{index()} to do its matching, and so returns
objects which partially match @var{string}.
@end deftypefn

@subsection The Trigonometric Utilities
This class provides various numerical routines, including trigonometric
routines, generation of number sequences, and permutations and
combinations.

The trigonometric routines all take a parameter @var{x} in degrees.
Result returned are to four decimal places, multiplied by 10000, so that
they can be represented by numbers.  For example:

@example
Verb Call                         Result
---------                         ------
:sin(0)                               0
:sin(90)                          10000
:sin(45)                           7063
:sin(270)                        -10000
@end example

@noindent
The following verbs are available:

@deftypefn Verb num sin (num @var{x})
This verb returns the sine of @var{x}, where @var{x} is in degrees.  The
returned value is to four decimal places, multiplied by 10000.
@end deftypefn

@deftypefn Verb num cos (num @var{x})
This verb returns the cosine of @var{x}, where @var{x} is in degrees.  The
returned value is to four decimal places, multiplied by 10000.
@end deftypefn

@deftypefn Verb num tan (num @var{x})
This verb returns the tangent of @var{x}, where @var{x} is in degrees.
The returned value is to four decimal places, multiplied by 10000.
@end deftypefn

@deftypefn Verb num xsin (num @var{x})
@deftypefnx Verb num xcos (num @var{x})
These two verbs are used by the above verbs to compute the sin, cos and
tan values using Taylor's Theorem.  They are not really of use to the
average programmer.
@end deftypefn

@deftypefn Verb num factorial (num @var{x})
This verb returns the factorial, using the traditional recursive method.
Note that @var{n} must be greater than or equal to 0.
@end deftypefn

@deftypefn Verb num pow (num @var{x}, num @var{n})
This verb returns @var{x} raised to the @var{n}th power.  Note that
@var{n} must be greater than or equal to 0.  Again, a recursive method
is used to generate the result.
@end deftypefn

@deftypefn Verb list exp (num @var{x} [, num @var{n}])
This verb calculates an @var{n}th order Taylor approximation for
@code{e}^@var{x}.  @var{n} defaults to 5.  The result returned is in the
format:

@example
@{@var{integer part}, @var{fractional part}@}
@end example

@noindent
For example,

@example
>;$trig_utils:exp(1)
 @print{}@{2, 71666@}

>;$trig_utils:exp(2, 6)
 @print{}@{7, 35555@}
@end example
@end deftypefn

@deftypefn Verb list fibonacci (num @var{n})
This verbn calculates the Fibonacci sequence to the @var{n}th term, and
returns the result as a list of numbers.  Note that @var{n} must be
greater than or equal to zero.

For example:

@example
>;$trig_utils:fibonacci(10)
 @print{} @{0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55@}
@end example
@end deftypefn

@deftypefn Verb num geometric (num @var{x}, num @var{n})
This verb calculates the value of the geometric series at @var{x} to the
@var{n}th term. i.e., it approximates @code{1/(1-x)} when @code{|x| <
1}. This, of course, is impossible in MOO, but someone may find it
useful in some way. @var{n} defaults to 5. Note that @var{n} must be
greater than or equal to zero.
@end deftypefn

@deftypefn Verb list div (num @var{n}, num @var{q})
This verb returns a decomposition of @var{n} by @var{q} using the
division algorithm. The returned list contains the divisor and the
remainder.

For example:

@example
Verb Call                     Returned
---------                     --------
;$trig_utils:div(5,1)          @{5, 0@}
;$trig_utils:div(5,2)          @{2, 1@}
;$trig_utils:div(5,3)          @{1, 2@}
;$trig_utils:div(5,4)          @{1, 1@}
;$trig_utils:div(5,5)          @{1, 0@}
@end example
@end deftypefn

@deftypefn Verb num combinations (num @var{n}, num @var{r})
This verb returns the number of ways one can choose @var{r} objects from
@var{n} distinct choices.  For example:

@example
Verb Call                              Returned
---------                              --------
;$trig_utils:combinations(5,1)            5  
;$trig_utils:combinations(5,2)            10
;$trig_utils:combinations(3,2)            3
@end example
@end deftypefn

@deftypefn Verb num permutations (num @var{n}, num @var{r})
This verb returns the number of ways possible for @var{r} objects to be
ordered given @var{n} distinct locations,using the formula 

@example
P(n,r) =  n!
        ----
        (n-r)!
@end example

For example:

@example
Verb Call                              Returned
---------                              --------
;$trig_utils:permutations(5,1)            5  
;$trig_utils:permutations(5,2)            20
;$trig_utils:permutations(3,2)            6
@end example
@end deftypefn

@deftypefn Verb list simpson (list @{num @var{a}, num @var{b}@}, list @{num @var{f(a)}, num @var{f((a+b)/2)}, num @var{f(b)}@})
Given two endpoints, @var{a} and @var{b}, and the function's value at
@var{a}, @var{(a+b)/2}, and @var{b}, this verb will calculate a
numerical approximation of the integral using Simpson's rule.  The
answer is returned in the form

@example
@{@var{integer part}, @var{fractional part}@}
@end example
@end deftypefn

@deftypefn Verb list abs (num @var{x})
This verb returns the absoluate value of @var{x}.  Note that this is
available in the server as the @code{abs()} primitive, so this verb is
redundant.
@end deftypefn

@deftypefn Verb list parts (num @var{n}, num @var{q} [, num @var{i}])
This verb returns a decomposition of @var{n} by @var{q} into integer and
floating point parts.  @var{i} gives the number of digits after the
decimal point.   If not given, @var{i} defaults to 5.  For example:

@example
Verb Call                       Returned
---------                       --------
;$trig_utils:parts(5,1)          @{5, 0@}
;$trig_utils:parts(5,2)          @{2, 50000@}
;$trig_utils:parts(3,2,2)        @{1,50@}  
@end example
@end deftypefn

@subsection The Time Utilities
The time utilities class, @code{$time_utils} provides a few useful
functions for dealing with dates and times.  The following verbs are
provided: 

@deftypefn Verb str day (@var{time})
This verb takes a time specification in @var{time}, and returns the full
name of the day.  This verb expects @var{time} to be the result of a
either the @code{time()} primitive or @var{ctime()}.  In the first case,
@var{time} is a number.  In the second case, @var{time} is a string.

For example,

@example
>;$time_utils:day(time())
 @print{}"Friday"
@end example

@noindent
The names for the days are stored on a property list called @code{days}
on the @code{$time_utils} class.  This is indexed from a list of
abbreviated day names, stored in a property list called @code{dayabbrs}.
@end deftypefn

@deftypefn Verb str month (@var{time})
This verb takes a time specification in @var{time}, and returns the full
name of the month.  This verb expects @var{time} to be the result of a
either the @code{time()} primitive or @var{ctime()}.  In the first case,
@var{time} is a number.  In the second case, @var{time} is a string.

For example,

@example
>;$time_utils:month(time())
 @print{}"July"
@end example

@noindent
The names for the months are stored on a property list called
@code{months} on the @code{$time_utils} class.  This is indexed from a
list of abbreviated month names, stored in a property list called
@code{monthabbrs}. 
@end deftypefn

@deftypefn Verb string ampm (@var{time} [,num @var{precision})
This verb takes a time specification in @var{time}, and returns string
containing a time in the form
@example
[h]h[:mm[:ss]] @{a.m.|p.m.@}
@end example

@noindent
@var{time} is either the result of the @code{time()} or @var{ctime()}
primitives, and is either a number or a string respectively.  If given,
@var{precision} specifies the accuracy required:

@display
@table @code
@item 1
Only the hours are returned.
@item 2
The hours and minutes are returned.
@item 3
The hours, minutes and seconds are returned.
@end table
@end display
If not given, then @var{precision} defaults to minutes.  For example,

@example
Verb Call                   Returns
---------                   -------
:ampm(time())                "8:58 p.m."
:ampm(time(), 1)             "8 p.m."
:ampm(time(), 2)             "8:58 p.m."
:ampm(time(), 3)             "8:58:23 p.m."
@end example
@end deftypefn

@deftypefn Verb num to_seconds (str @var{string})
This verb takes a @var{string} in the form 
@example
hh:mm:ss
@end example
@noindent
for example, created using the expression
@example
$string_utils:explode(ctime(time))[4]
@end example
@noindent
and returns the number of seconds elapsed since 00:00:00.
@end deftypefn

@deftypefn Verb num sun ([num @var{time}])
I can't work out what this verb is supposed to do.  I include the code
for those interested persons who might find it useful.

@example
r = 10000;
h = r * r + r / 2;
time = args == @{@} ? time() | args[1];
t = (time + 120) % 86400 / 240;
s = 5 * ((time - 14957676) % 31556952) / 438291;
phi = s + t + this.corr;
cs = $trig_utils:cos(s);
spss = ($trig_utils:sin(phi) * $trig_utils:sin(s) + h) / r - r;
cpcs = ($trig_utils:cos(phi) * cs + h) / r - r;
return (this.stsd * cs - this.ctcd * cpcs - this.ct * spss + h) / r - r;
@end example
@end deftypefn

@deftypefn Verb num from_ctime (str @var{string})
This verb, given a string such as that returned by @code{ctime()},
returns the corresponding time-in-seconds-since-1970 time returned by
@code{time()}, or @code{E_DIV }if the format is wrong in some essential
way. Note that @code{ctime()} doesn't return a time zone, yet it
arbitrarily decides whether it's standard or daylight savings time.
@end deftypefn

The following properties are defined on the @code{$time_utils} class:

@defvr Property stsd
@defvrx Property ctcd
@defvrx Property ct 
@defvrx Property corr 
These properties are used by the mysterious @code{$time_utils:sun()}
verb.  Becuase of this, I have no comment to make on what information
they contain, or how they are used.
@end defvr

@defvr Property dayabbrs 
This property contains a list of day abbreviations, such as are found in
the string returned by @code{ctime()}.  They are used to produce an
index into the property @code{days}, that contains the full names of
each day of the week.
@end defvr

@defvr Property days 
This property contains a list of the seven full names of the days of the
week. 
@end defvr

@defvr Property months 
This property contains a list of the twelve full names of the months of
the year.
@end defvr

@defvr Property monthabbrs 
This property contains a list of month name abbreviations, such as are
returned from @code{ctime()}.  They are used to produce an index into
the property @code{months}, that contains the full names of each month
of the year.
@end defvr

@defvr Property zones 
This contains a list of some time zones, for some random purpose as yet
unknown.  If anyone can enlighten me.....
@end defvr

@subsection The Gender Utilities
The gender utilities class, @code{$gender_utils} contains a couple of
verbs used for manipulating the gender pronouns of objects.

@deftypefn Verb num set (obj @var{object}, str @var{gender})
This verb is used to set the pronoun properties of @var{object},
according to the @var{gender} specified.  @var{gender} is a string: one
of the strings in the property list @code{$gender_utils.genders}, the
list of rcognized genders.  

The verb checks @var{gender} against the gender list, and sets the
pronouns on @var{object} with strings taken from property lists stored
on @code{$gender_utils}.  If the gender change is successful, the (full)
name of the gender (e.g., @samp{female}) is returned.  @code{E_NONE} is
returned if gender does not match any recognized gender.  Any other
error encountered (e.g., @code{E_PERM}, @code{E_PROPNF}) is likewise
returned and the object's pronoun properties are left unaltered.
@end deftypefn

@deftypefn Verb num add (obj @var{object} [,str @var{perms}] [, obj @var{owner}])
This verb is used to add pronoun properties to @var{object} if they are
not already there.  The @var{owner} and @var{perms} arguments allow you
to optionally specify the permissions and owner of the gender properties
that are being created.  If not given, @var{owner} defaults to the
object's owner, and @var{perms} defaults to @samp{rc}.
@end deftypefn

The following properties are defined on the @code{$gender_utils} class:

@defvr Property pronouns
This property holds a list of the pronoun properties that can be given
to an object.  It is used by the @code{$gender_utils:add} verb when
adding the gender properties to an object.
@end defvr

@defvr Property genders
This property holds a list of legal genders for objects, as strings.
@end defvr

@defvr Property ps
This property holds the subjective pronouns for each different gender.
If a gender is given by @code{$gender_utils.genders[@var{x}]}, then the
corresponding gender pronouns is given by
@code{$gender_utils:ps[@var{x}]}. 
@end defvr

@defvr Property po
This property holds the objective pronouns for each different gender.
If a gender is given by @code{$gender_utils.genders[@var{x}]}, then the
corresponding gender pronouns is given by
@code{$gender_utils:po[@var{x}]}. 
@end defvr

@defvr Property pp
This property holds the possessive pronouns for each different gender.
If a gender is given by @code{$gender_utils.genders[@var{x}]}, then the
corresponding gender pronouns is given by
@code{$gender_utils:pp[@var{x}]}. 
@end defvr

@defvr Property pq
This property holds the possessive pronouns, in the noun form, for each
different gender.  If a gender is given by
@code{$gender_utils.genders[@var{x}]}, then the corresponding gender
pronouns is given by @code{$gender_utils:pq[@var{x}]}.
@end defvr

@defvr Property pr
This property holds the reflexive pronouns for each different gender.
If a gender is given by @code{$gender_utils.genders[@var{x}]}, then the
corresponding gender pronouns is given by
@code{$gender_utils:pr[@var{x}]}. 
@end defvr

@defvr Property psc
This property holds the capitalised subjective pronouns for each
different gender.  If a gender is given by
@code{$gender_utils.genders[@var{x}]}, then the corresponding gender
pronouns is given by @code{$gender_utils:psc[@var{x}]}.
@end defvr

@defvr Property poc
This property holds the capitalised objective pronouns for each
different gender.  If a gender is given by
@code{$gender_utils.genders[@var{x}]}, then the corresponding gender
pronouns is given by @code{$gender_utils:poc[@var{x}]}.
@end defvr

@defvr Property ppc
This property holds the capitalised possessive pronouns for each
different gender.  If a gender is given by
@code{$gender_utils.genders[@var{x}]}, then the corresponding gender
pronouns is given by @code{$gender_utils:ppc[@var{x}]}.
@end defvr

@defvr Property pqc
This property holds the capitalised possessive pronouns, in their noun
form, for each different gender.  If a gender is given by
@code{$gender_utils.genders[@var{x}]}, then the corresponding gender
pronouns is given by @code{$gender_utils:pqc[@var{x}]}.
@end defvr

@defvr Property prc
This property holds the capitalised reflexive pronouns for each
different gender.  If a gender is given by
@code{$gender_utils.genders[@var{x}]}, then the corresponding gender
pronouns is given by @code{$gender_utils:prc[@var{x}]}.
@end defvr

@chapter Common Questions - How to do Useful Things
To be written.

@iftex
@unnumbered Verb Index
@printindex fn

@unnumbered Property Index
@printindex vr

@contents
@end iftex

@bye
@c Local Variables:
@c makeinfo-options: "+fill-column 79 +no-split"
@c End:


