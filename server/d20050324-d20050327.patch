diff -Nur d20050324/projects/moo/src/bf_register.h d20050327/projects/moo/src/bf_register.h
--- d20050324/projects/moo/src/bf_register.h	2004-03-22 11:14:53.000000000 -0500
+++ d20050327/projects/moo/src/bf_register.h	2005-03-27 23:56:21.000000000 -0500
@@ -27,4 +27,7 @@
 extern void register_server(void);
 extern void register_tasks(void);
 extern void register_verbs(void);
+/* bg_name_lookup */
+extern void register_name_lookup(void);
+/* !bg_name_lookup */
 
diff -Nur d20050324/projects/moo/src/bg_name_lookup.c d20050327/projects/moo/src/bg_name_lookup.c
--- d20050324/projects/moo/src/bg_name_lookup.c	1969-12-31 19:00:00.000000000 -0500
+++ d20050327/projects/moo/src/bg_name_lookup.c	2005-03-27 23:56:21.000000000 -0500
@@ -0,0 +1,823 @@
+#include <errno.h>
+#include <signal.h>
+#include <netdb.h>      /* gethostby{name,addr}() */
+#include <unistd.h>     /* write(), read(), sleep(), alarm() */
+#include <stdlib.h>     /* malloc(), free() */
+#include <netinet/in.h> /* inet_ntoa() */
+#include <arpa/inet.h>  /* ditto */
+
+#include "tasks.h"
+#include "structures.h"
+#include "functions.h"
+#include "utils.h"
+#include "list.h"
+#include "my-in.h"
+
+#include "log.h"        /* errlog() */
+#include "exceptions.h" /* panic() */
+#include "net_multi.h"  /* network_{,un}register_fd() */
+#include "storage.h"    /* str_dup() */
+#include "server.h"     /* set_server_cmdline() */
+
+struct async_name_lookup_info
+{
+  enum { ASYNC_FROM_ADDR, ASYNC_FROM_NAME } kind;
+ 
+  unsigned timeout;
+  unsigned started;
+ 
+  union
+  {
+    char *name;
+    struct in_addr address;
+  } u;
+ 
+  pid_t pid;
+  int pipe_fd;
+ 
+  vm the_vm;
+ 
+  struct async_name_lookup_info *next;
+};
+
+struct async_request /* Same as name_lookup.c's struct request */
+{
+  enum { REQ_FROM_ADDR, REQ_FROM_NAME } kind;
+
+  unsigned timeout;
+
+  union
+  {
+    unsigned length;
+    /* struct sockaddr_in address; Why? */
+    struct in_addr address;
+  } u;
+};
+
+struct async_reply
+{
+  enum { AR_SUCCESS, AR_FAILURE } success;
+ 
+  enum error error;
+ 
+  int num_aliases;
+  int num_addresses;
+};
+ 
+typedef struct async_reply async_reply;
+typedef struct async_request async_request;
+
+struct async_name_lookup_info *async_name_lookup_info = 0;
+int                            async_name_lookup_len  = 0;
+
+static task_enum_action lookup_task_queue_enumerator(task_closure closure, void *data);
+static void async_name_lookup_readable(int fd, struct async_name_lookup_info *info_ptr);
+static struct async_name_lookup_info *dequeue_lookup_task(struct async_name_lookup_info *info_ptr);
+
+static struct async_name_lookup_info *async_lookup_from_name(const char *name, unsigned timeout);
+static struct async_name_lookup_info *async_lookup_from_addr(struct in_addr addr, unsigned timeout);
+
+static void async_lookup_from_addr_child(int to_parent, int from_parent);
+static void async_lookup_from_name_child(int to_parent, int from_parent);
+
+static void async_child_catch_alarm(int sig);
+
+/*** Utils ***/
+
+static int  /* Shamelessly stolen from name_lookup.c */
+robust_read(int fd, void *buffer, int len)
+{
+    int count;
+ 
+    do {
+        count = read(fd, buffer, len);
+    } while (count == -1 && errno == EINTR);
+ 
+    return count;
+} 
+
+static inline int
+robust_write(int fd, void *buffer, int len)
+{
+  int ret;
+
+  while (((ret = write(fd, buffer, len)) == -1) && (errno == EINTR))
+    ;
+
+  return ret;
+}
+
+/* Writes the string length followed by the string to an fd.
+ */
+static inline int
+string_write(int fd, char *str)
+{
+  int    ret;
+  size_t size;
+
+  size = strlen(str);
+  
+  ret = robust_write(fd, &size, sizeof(size));
+  if (ret != sizeof(size)) return ret;
+
+  ret = robust_write(fd, str, size);
+  return ret;
+}
+
+/* Reads a string length followed by a string.
+ * Returns NULL on error. Otherwise caller should free().
+ */
+static inline char *
+string_read(int fd)
+{
+  int ret;
+  size_t size;
+  char *str;
+
+  ret = robust_read(fd, &size, sizeof(size));
+  if (ret != sizeof(size)) return NULL;
+
+  str = malloc(size+1);
+  if (str == NULL) panic("STRING_READ: Out of memory.\n");
+
+  ret = robust_read(fd, str, size);
+  if (ret != size)
+  {
+    free(str);
+    return NULL;
+  }
+
+  str[size] = '\0';
+  return str;
+}
+
+
+/* Task queue stuff */
+
+
+/* Enumerator for custom task queue. Target of register_task_queue().
+ */
+static task_enum_action
+lookup_task_queue_enumerator(task_closure closure, void *data)
+{
+  int x;
+  struct async_name_lookup_info *info_ptr;
+  task_enum_action tea;
+  static const char status[] = "name_lookup()";
+ 
+  info_ptr = async_name_lookup_info;
+
+  for (x=1; x<=async_name_lookup_len; x++)
+  {
+    if (!info_ptr)
+      panic("LOOKUP_TASK_QUEUE_ENUMERATOR: Ran off end of linked list!");
+ 
+    tea = (*closure)(info_ptr->the_vm, status, data);
+ 
+    if (tea == TEA_KILL)
+    {
+      errlog("LOOKUP_TASK_QUEUE_ENUMERATOR: TEA_KILL\n");
+      dequeue_lookup_task(info_ptr);
+    }
+ 
+    if (tea != TEA_CONTINUE)
+      return tea;
+ 
+    info_ptr=info_ptr->next;
+  }
+ 
+  return TEA_CONTINUE;
+} 
+
+
+static enum error
+enqueue_lookup_task(vm the_vm, struct async_name_lookup_info *info_ptr)
+{
+  struct async_name_lookup_info **info_walk;
+
+  network_register_fd(info_ptr->pipe_fd, async_name_lookup_readable, NULL, info_ptr);
+  info_ptr->the_vm = the_vm;
+
+  /* Easier to throw them on the beginning, but oh well */
+  info_walk = &async_name_lookup_info;
+  while (*info_walk)
+  {
+    info_walk=&((*info_walk)->next);
+  }
+ 
+  *info_walk = info_ptr;
+
+  async_name_lookup_len++;
+ 
+  return E_NONE;
+}
+
+
+/* Scans the name lookup queue for the pointer we are given, and deletes it
+ * from the list. Returns a pointer to the next item in the list.
+ */
+static struct async_name_lookup_info *
+dequeue_lookup_task(struct async_name_lookup_info *info_ptr)
+{
+  struct async_name_lookup_info **info_walk;
+  int x=0;
+  int cleaned=0;
+ 
+  network_unregister_fd(info_ptr->pipe_fd);
+  close(info_ptr->pipe_fd);
+ 
+  for (info_walk=&async_name_lookup_info; *info_walk; info_walk=&((*info_walk)->next))
+  {
+    if (*info_walk == info_ptr)
+    {
+      struct async_name_lookup_info *next;
+
+      next = (*info_walk)->next; 
+      free(*info_walk);
+      *info_walk = next;
+      cleaned = 1;
+      break;
+    }
+ 
+    if (++x > async_name_lookup_len)
+      panic("DEQUEUE_LOOKUP_TASK: Queue is longer than it should be. :-(");
+  }
+ 
+  if (!cleaned)
+    panic("DEQUEUE_LOOKUP_TASK: Failed to clean up.");
+ 
+  async_name_lookup_len--;
+ 
+  return *info_walk;
+}
+
+
+/* Callback set in place with network_register_fd().
+ */
+static void
+async_name_lookup_readable(int fd, struct async_name_lookup_info *info_ptr)
+{
+  async_reply rep;
+  Var r;
+ 
+  char *name;
+ 
+  if ((robust_read(info_ptr->pipe_fd, &rep, sizeof(rep)) != sizeof(rep)))
+  {
+    /* fd was probably closed as child died */
+    r.type  = TYPE_ERR;
+    r.v.err = E_VARNF;
+  }
+  else if (rep.success == AR_FAILURE)
+  {
+    /* Child reported an error, just return that */
+    r.type  = TYPE_ERR;
+    r.v.err = rep.error;
+  }
+  else if ((name = string_read(fd)) == NULL)
+  {
+    /* fd was probably closed as child died */
+    r.type  = TYPE_ERR;
+    r.v.err = E_VARNF;
+  }
+  else
+  {
+    int x;
+    char          **alias_list;
+    struct in_addr *addr_list;
+
+    if ((alias_list = calloc(rep.num_aliases, sizeof(alias_list[0]))) == NULL)
+    {
+      panic("ASYNC_NAME_LOOKUP_READABLE: Out of memory\n");
+    }
+
+    if ((addr_list = calloc(rep.num_addresses, sizeof(struct in_addr))) == NULL)
+    {
+      panic("ASYNC_NAME_LOOKUP_READABLE: Out of memory\n");
+    }
+
+    /* Read the alias ptrs into our array */
+    for (x=0; x<rep.num_aliases; x++)
+    {
+      alias_list[x] = string_read(info_ptr->pipe_fd);
+      /* oklog("Alias %d: %s\n", x, alias_list[x]); */
+      /* Should do something smarter on error */
+      if (alias_list[x] == NULL)
+        panic("ASYNC_NAME_LOOKUP_READABLE: Couldn't read alias.\n");
+    }
+
+    /* Read the addrs */
+    for (x=0; x<rep.num_addresses; x++)
+    {
+      /* Should do something smarter on error */
+      if (robust_read(info_ptr->pipe_fd, &(addr_list[x].s_addr), sizeof(addr_list[0].s_addr)) != sizeof(addr_list[0].s_addr))
+        panic("ASYNC_NAME_LOOKUP_READABLE: Couldn't read address.\n");
+      /* oklog("Address %d: %s\n", x, inet_ntoa(addr_list[x])); */
+    }
+
+    /* Yay, return successful result */
+    r = new_list(3);
+
+    r.v.list[1].type  = TYPE_STR;
+    r.v.list[1].v.str = str_dup(name);
+
+    r.v.list[2] = new_list(rep.num_aliases);
+    for (x=0; x<rep.num_aliases; x++)
+    {
+      r.v.list[2].v.list[x+1].type  = TYPE_STR;
+      r.v.list[2].v.list[x+1].v.str = str_dup(alias_list[x]);
+    }
+
+    r.v.list[3] = new_list(rep.num_addresses);
+    for (x=0; x<rep.num_addresses; x++)
+    {
+      unsigned char *y=(unsigned char *) &(addr_list[x].s_addr);
+
+      r.v.list[3].v.list[x+1] = new_list(4);
+      r.v.list[3].v.list[x+1].v.list[1].type  = TYPE_INT;
+      r.v.list[3].v.list[x+1].v.list[1].v.num = (int) *y++;
+      r.v.list[3].v.list[x+1].v.list[2].type  = TYPE_INT;
+      r.v.list[3].v.list[x+1].v.list[2].v.num = (int) *y++;
+      r.v.list[3].v.list[x+1].v.list[3].type  = TYPE_INT;
+      r.v.list[3].v.list[x+1].v.list[3].v.num = (int) *y++;
+      r.v.list[3].v.list[x+1].v.list[4].type  = TYPE_INT;
+      r.v.list[3].v.list[x+1].v.list[4].v.num = (int) *y++;
+    }
+
+    /* Free all our stuff */
+    free(name);
+    free(alias_list);
+    free(addr_list);
+  }
+ 
+  resume_task(info_ptr->the_vm, r);
+ 
+  /* Clean up */
+  dequeue_lookup_task(info_ptr);
+ 
+  return;
+}
+
+
+/*** Builtin function stuff ***/
+ 
+
+/* bf_name_lookup(str/list addr, int timeout) => {str name, list aliases, list addresses}
+ * E_PERM    - Not a wizard.
+ * E_RECMOVE - Problem starting name lookup.
+ * E_VARNF   - Name lookup died. (Timeout)
+ * Results from gethostbyname():
+ * E_PROPNF  - Host was not found.
+ * E_MAXREC  - Temporary error, try again.
+ * E_INVIND  - Host exists but has no address information.
+ * E_VERBNF  - Unrecoverable error.
+ */
+static package
+bf_name_lookup(Var arglist, Byte next, void *vdata, Objid progr)
+{
+  Var r;  /* probably unneeded */
+  struct async_name_lookup_info *info_ptr;
+ 
+  int timeout = arglist.v.list[2].v.num;
+ 
+  if (!is_wizard(progr))
+  {
+    free_var(arglist);
+    return make_error_pack(E_PERM);
+  }
+ 
+  switch (arglist.v.list[1].type)
+  {
+  case TYPE_STR:
+    if ((info_ptr = async_lookup_from_name(arglist.v.list[1].v.str, timeout)) == NULL)
+    {
+      free_var(arglist);
+      return make_error_pack(E_RECMOVE);  /* Problem starting or talking to child */
+    }
+    else
+    {
+      free_var(arglist);
+      return make_suspend_pack(enqueue_lookup_task, info_ptr);
+    }
+ 
+    break;
+  case TYPE_LIST:
+    if (arglist.v.list[1].v.list[0].v.num != 4)
+    {
+      free_var(arglist);
+      return make_error_pack(E_INVARG);
+    }
+    else
+    {
+      int x;
+      struct in_addr tmp_addr;
+      unsigned char *y = (unsigned char *) &(tmp_addr.s_addr);
+
+      /* We have a list of length 4. Turn it into an IP. */
+      for (x=1; x<=4; x++)
+      {
+        if ((arglist.v.list[1].v.list[x].type != TYPE_INT) ||
+            (arglist.v.list[1].v.list[x].v.num < 0)        ||
+            (arglist.v.list[1].v.list[x].v.num > 255))
+        {
+          free_var(arglist);
+          return make_error_pack(E_INVARG);
+        }
+        else
+          *y++ = (unsigned char) arglist.v.list[1].v.list[x].v.num;
+      }
+
+      free_var(arglist); /* We're done with them at this point */
+
+      /* Try to look it up. */
+      if ((info_ptr = async_lookup_from_addr(tmp_addr, timeout)) == NULL)
+        return make_error_pack(E_RECMOVE);  /* Problem starting or talking to child */
+      else
+        return make_suspend_pack(enqueue_lookup_task, info_ptr);
+    }
+
+    break;
+  default:
+    free_var(arglist);
+    return make_error_pack(E_TYPE);
+    break;
+  }
+ 
+  /* Hmm... */
+  errlog("BF_NAME_LOOKUP: How did we get here?\n");
+
+  r.type = TYPE_INT;
+  r.v.num = 0;
+
+  free_var(arglist);
+  return make_var_pack(r);
+}
+
+
+
+/* bf_name_lookups() => {{str/list addr, int timeout, int started, int task_id}, ...}
+ */
+static package
+bf_name_lookups(Var arglist, Byte next, void *vdata, Objid progr)
+{
+  Var r;
+  int x;
+  struct async_name_lookup_info *info_ptr;
+ 
+  if (!is_wizard(progr))
+  {
+    free_var(arglist);
+    return make_error_pack(E_PERM);
+  }
+ 
+  info_ptr = async_name_lookup_info;
+  r = new_list(async_name_lookup_len);
+ 
+  for (x=1; x<=async_name_lookup_len; x++)
+  {
+    r.v.list[x] = new_list(4);
+ 
+    if (!info_ptr)
+      panic("BF_NAME_LOOKUPS: Ran off end of linked list!");
+ 
+    r.v.list[x].v.list[1].type = TYPE_STR;
+    r.v.list[x].v.list[1].v.str = str_dup(info_ptr->u.name);
+ 
+    r.v.list[x].v.list[2].type = TYPE_INT;
+    r.v.list[x].v.list[2].v.num = info_ptr->timeout;
+ 
+    r.v.list[x].v.list[3].type = TYPE_INT;
+    r.v.list[x].v.list[3].v.num = info_ptr->started;
+ 
+    r.v.list[x].v.list[4].type = TYPE_INT;
+    r.v.list[x].v.list[4].v.num = info_ptr->the_vm->task_id;
+ 
+    info_ptr = info_ptr->next;
+  }
+ 
+  free_var(arglist);
+  return make_var_pack(r);
+} 
+
+
+void
+register_name_lookup()
+{ 
+  register_task_queue(lookup_task_queue_enumerator);
+  (void) register_function("name_lookup", 2, 2, bf_name_lookup, TYPE_ANY, TYPE_INT);
+  (void) register_function("name_lookups", 0, 0, bf_name_lookups);
+}
+
+
+/*** Interface with child stuff ***/
+
+
+/* Hmm.
+ * We probably inherit signal handlers?
+ * And we should probably close() the network fd's?
+ */
+static pid_t spawn_async_lookup(void (*child_proc) (int to_parent, int from_parent),
+                                 int *to_child, int *from_child)
+{
+  int pipe_to_child[2], pipe_from_child[2];
+  pid_t pid;
+ 
+  if (pipe(pipe_to_child) < 0) {
+    log_perror("SPAWN_ASYNC_LOOKUP: Couldn't create first pipe");
+  } else if (pipe(pipe_from_child) < 0) {
+    log_perror("SPAWN_ASYNC_LOOKUP: Couldn't create second pipe");
+    close(pipe_to_child[0]);
+    close(pipe_to_child[1]);
+  } else if ((pid = fork()) < 0) {
+    log_perror("SPAWN_ASYNC_LOOKUP: Couldn't fork name lookup process");
+    close(pipe_to_child[0]);
+    close(pipe_to_child[1]);
+    close(pipe_from_child[0]);
+    close(pipe_from_child[1]);
+  } else if (pid != 0) {      /* parent */
+ 
+    close(pipe_to_child[0]);
+    close(pipe_from_child[1]);
+    *to_child = pipe_to_child[1];
+    *from_child = pipe_from_child[0];
+ 
+    return pid;
+  } else {                   /* child */
+    close(pipe_to_child[1]);
+    close(pipe_from_child[0]);
+ 
+    signal(SIGALRM, async_child_catch_alarm);
+ 
+    (*child_proc) (pipe_from_child[1], pipe_to_child[0]);
+    exit(0);
+  }
+ 
+  return 0;
+} 
+
+
+static struct async_name_lookup_info *
+async_lookup_from_name(const char *name, unsigned timeout)
+{
+  struct async_name_lookup_info *info_new;
+ 
+  async_request req;
+
+  int pid;
+  int to_child, from_child;
+ 
+ 
+  if ((info_new=malloc(sizeof(struct async_name_lookup_info))) == NULL)
+  {
+    errlog("ASYNC_LOOKUP_FROM_NAME: Malloc failed.\n");
+    return NULL;
+  }
+ 
+  pid = spawn_async_lookup(async_lookup_from_name_child, &to_child, &from_child);
+  if (!pid)
+  {
+    errlog("ASYNC_LOOKUP_FROM_NAME: Could not spawn child!\n");
+    free(info_new);
+    return NULL;
+  }
+ 
+  req.kind     = REQ_FROM_NAME;
+  req.timeout  = timeout;
+  req.u.length = strlen(name);
+ 
+  if (robust_write(to_child, &req, sizeof(req)) == -1)
+  {
+    log_perror("ASYNC_LOOKUP_FROM_NAME: Couldn't write request to child");
+    free(info_new);
+    return NULL;
+  }
+ 
+  if (robust_write(to_child, name, req.u.length) == -1)
+  {
+    log_perror("ASYNC_LOOKUP_FROM_NAME: Couldn't write name to child");
+    free(info_new);
+    return NULL;
+  }
+ 
+  close(to_child);
+ 
+  info_new->timeout = timeout;
+  info_new->started = time(NULL);
+  info_new->u.name  = str_dup(name);
+  info_new->pid     = pid;
+  info_new->pipe_fd = from_child;
+  info_new->next    = 0;
+ 
+  return info_new;
+} 
+
+
+static struct async_name_lookup_info *
+async_lookup_from_addr(struct in_addr addr, unsigned timeout)
+{
+  struct async_name_lookup_info *info_new;
+ 
+  async_request req;
+
+  int pid;
+  int to_child, from_child;
+
+ 
+  if ((info_new=malloc(sizeof(struct async_name_lookup_info))) == NULL)
+  {
+    errlog("ASYNC_LOOKUP_FROM_ADDR: Malloc failed.\n");
+    return NULL;
+  }
+ 
+  pid = spawn_async_lookup(async_lookup_from_addr_child, &to_child, &from_child);
+  if (!pid)
+  {
+    errlog("ASYNC_LOOKUP_FROM_ADDR: Could not spawn child!\n");
+    free(info_new);
+    return NULL;
+  }
+ 
+  req.kind             = REQ_FROM_ADDR;
+  req.timeout          = timeout;
+  req.u.address.s_addr = addr.s_addr;
+ 
+  if (robust_write(to_child, &req, sizeof(req)) == -1)
+  {
+    log_perror("ASYNC_LOOKUP_FROM_ADDR: Couldn't write request to child");
+    free(info_new);
+    return NULL;
+  }
+
+  close(to_child);
+ 
+  info_new->timeout          = timeout;
+  info_new->started          = time(NULL);
+  info_new->u.address.s_addr = addr.s_addr;
+  info_new->pid              = pid;
+  info_new->pipe_fd          = from_child;
+  info_new->next             = 0;
+
+  return info_new;
+} 
+
+
+/*** Runs in child ***/
+
+/* Name lookup process timed out. Give up.
+ */
+static void
+async_child_catch_alarm(int sig)
+{
+  _exit(1);
+}
+
+
+/* Called from async_lookup_from_{name,addr}_child.
+ * Figures out what our name lookup answer was, and tells the parent about it.
+ */
+static void process_lookup_answer(int to_parent, struct hostent *answer)
+{
+  async_reply   rep;
+
+  if (answer == NULL)
+  {
+    /* Report failure */
+    rep.success = AR_FAILURE;
+ 
+    switch (h_errno)
+    {
+    case HOST_NOT_FOUND:
+      rep.error   = E_PROPNF;
+      break;
+    case TRY_AGAIN:
+      rep.error   = E_MAXREC;
+      break;
+    case NO_DATA:
+      rep.error   = E_INVIND;
+      break;
+    default:
+      rep.error   = E_VERBNF;
+      break;
+    }
+ 
+    write(to_parent, &rep, sizeof(rep));
+ 
+    _exit(1);
+  }
+  else
+  {
+    int x;
+
+    char ** addr_list = answer->h_addr_list;
+    char **alias_list = answer->h_aliases;
+
+ 
+    /* Report success */
+    rep.success = AR_SUCCESS;
+    rep.error   = E_NONE;
+ 
+    /* Count the number of aliases */
+    for (x=0; alias_list[x]; x++)
+      ;
+    rep.num_aliases = x;
+ 
+    /* Count the number of addresses */
+    for (x=0; addr_list[x]; x++)
+      ;
+    rep.num_addresses = x;
+    
+    /* sleep(10); */
+    robust_write(to_parent, &rep, sizeof(rep));
+
+    /* Write the CNAME */
+    string_write(to_parent, answer->h_name);
+
+    /* Write the list of aliases */
+    for (x=0; x < rep.num_aliases; x++)
+      string_write(to_parent, alias_list[x]);
+
+    /* Write the list of addresses */
+    for (x=0; x < rep.num_addresses; x++)
+      robust_write(to_parent, addr_list[x], answer->h_length);
+  }
+
+}
+
+
+static void async_lookup_from_name_child(int to_parent, int from_parent)
+{
+  async_request req;
+  char *name, *cmdline;
+  struct hostent *answer;
+ 
+  if (robust_read(from_parent, &req, sizeof(req)) != sizeof(req)) {
+    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Read of request failed.\n");
+    _exit(1);
+  }
+  else if (req.kind != REQ_FROM_NAME) {
+    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Unexpected request kind.\n");
+    _exit(1);
+  }
+  else if ((name = malloc(req.u.length + 1)) == NULL) {
+    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Out of memory\n");
+    _exit(1);
+  }
+  else if (robust_read(from_parent, name, req.u.length) != req.u.length) {
+    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Read of name failed.\n");
+    _exit(1);
+  }
+ 
+  name[req.u.length]='\0';
+
+  /* Set the command line while we're doing our lookup */
+  cmdline=malloc(50+req.u.length);
+  if (cmdline != NULL)
+  {
+    sprintf(cmdline, "(MOO async name lookup: %s)", name);
+    set_server_cmdline(cmdline);
+    free(cmdline);
+  }
+ 
+  alarm(req.timeout);
+ 
+  answer = gethostbyname(name);
+
+  alarm(0);
+
+  process_lookup_answer(to_parent, answer);
+
+  return;
+}   
+
+
+static void async_lookup_from_addr_child(int to_parent, int from_parent)
+{
+  async_request req;
+  char cmdline[50];
+  struct hostent *answer;
+ 
+  if (robust_read(from_parent, &req, sizeof(req)) != sizeof(req)) {
+    errlog("ASYNC_LOOKUP_FROM_ADDR_CHILD: Read of request failed.\n");
+    _exit(1);
+  }
+  else if (req.kind != REQ_FROM_ADDR) {
+    errlog("ASYNC_LOOKUP_FROM_ADDR_CHILD: Unexpected request kind.\n");
+    _exit(1);
+  }
+
+  /* Set the command line while we're doing our lookup */
+  sprintf(cmdline, "(MOO async name lookup: %s)", inet_ntoa(req.u.address));
+  set_server_cmdline(cmdline);
+ 
+  alarm(req.timeout);
+ 
+  answer = gethostbyaddr((void *) &(req.u.address.s_addr), sizeof(req.u.address.s_addr), AF_INET);
+
+  alarm(0);
+
+  process_lookup_answer(to_parent, answer);
+
+  return;
+}   
+
+
diff -Nur d20050324/projects/moo/src/bg_name_lookup.patch d20050327/projects/moo/src/bg_name_lookup.patch
--- d20050324/projects/moo/src/bg_name_lookup.patch	1969-12-31 19:00:00.000000000 -0500
+++ d20050327/projects/moo/src/bg_name_lookup.patch	2005-03-27 23:56:21.000000000 -0500
@@ -0,0 +1,1111 @@
+diff -Nur MOO-1.8.1-old/BG_NAME_LOOKUP.txt MOO-1.8.1-bg/BG_NAME_LOOKUP.txt
+--- MOO-1.8.1-old/BG_NAME_LOOKUP.txt	Wed Dec 31 19:00:00 1969
++++ MOO-1.8.1-bg/BG_NAME_LOOKUP.txt	Sat Dec  9 22:03:11 2000
+@@ -0,0 +1,90 @@
++The MOO programmer's manual has this to say about name lookups:
++--- snip ---
++Accepting and Initiating Network Connections
++--------------------------------------------
++ 
++   When the server first accepts a new, incoming network connection, it is
++given the low-level network address of computer on the other end.  It
++immediately attempts to convert this address into the human-readable host name
++that will be entered in the server log and returned by the `connection_name()'
++function.  This conversion can, for the TCP/IP networking configurations,
++involve a certain amount of communication with remote name servers, which can
++take quite a long time and/or fail entirely.  While the server is doing this
++conversion, it is not doing anything else at all; in particular, it it not
++responding to user commands or executing MOO tasks.
++ 
++   By default, the server will wait no more than 5 seconds for such a name
++lookup to succeed; after that, it behaves as if the conversion had failed,
++using instead a printable representation of the low-level address.  If the
++property `name_lookup_timeout' exists on `$server_options' and has an integer
++as its value, that integer is used instead as the timeout interval.
++--- snip ---
++
++I think a much better solution would be to handle these name server lookups in
++the background instead of "not doing anything else at all". That's what this
++patch is supposed to do.
++
++The idea is to no longer have the MOO attempt to do name lookups automatically
++when someone connects. Instead, a couple new builtin functions allow
++in-database code to explicitly request a name lookup. This also gives you the
++choice of not attempting to look up the name at all, for example if your MOO
++also serves web requests.
++
++This changes connection_name() to always return the IP address instead of the
++name, as if the automatic lookup had timed out.
++
++Added are name_lookup() which performs a name lookup, and name_lookups(), which
++returns a list of the name lookups that are in progress.
++
++The $server_options.name_lookup_timeout property is still useful. The
++open_network_connection() function still uses the old name lookup system, and
++needs a timeout.
++
++The queued_tasks() function now returns "name_lookup()" in place of the usual
++value that tells us at what time the verb will be done suspending.
++
++---
++
++Two new builtin functions:
++
++name_lookups() => {list info, ...}
++
++This function returns a list of background name lookups that are in progress.
++One `info' list is returned for each lookup. It has this format:
++
++{str/list address, int timeout, int started, int task_id}
++
++Address and timeout are the original values passed to the name_lookup() call.
++
++Started is the value of time() when the call took place.
++
++Task_id is the task id of the waiting program.
++
++name_lookup(str/list address, int timeout) =>
++ {str canonical-name, list aliases, list addresses}
++
++This function starts a new name lookup. The current verb suspends until the
++lookup is done, but the MOO server continues to process other commands.
++
++The address argument can be either a string such as "www.altavista.com", or a
++list describing an IP address. In one of these lists, the address
++192.168.0.14 becomes {192, 168, 0, 14}.
++
++The timeout arg is the number of seconds before this name lookup should be
++abandoned.
++
++For the return value, canonical-name is the proper name that was found.
++
++Aliases is a list of strings, each one giving an alternate name.
++
++Addresses is a list of lists, each one giving an IP address as described above.
++
++Both of these functions will raise E_PERM if you are not a wizard. 
++
++The name_lookup() function can also raise:
++E_RECMOVE - Problem starting name lookup.
++E_VARNF   - Timeout
++E_PROPNF  - Host was not found.
++E_MAXREC  - Temporary nameserver error, try again later.
++E_INVIND  - Host exists but has no address information.
++E_VERBNF  - Unrecoverable nameserver error.
+diff -Nur MOO-1.8.1-old/Makefile.in MOO-1.8.1-bg/Makefile.in
+--- MOO-1.8.1-old/Makefile.in	Mon Jan 10 20:54:05 2000
++++ MOO-1.8.1-bg/Makefile.in	Sat Dec  9 22:00:55 2000
+@@ -35,7 +35,8 @@
+ 	log.c malloc.c match.c md5.c name_lookup.c network.c net_mplex.c \
+ 	net_proto.c numbers.c objects.c parse_cmd.c pattern.c program.c \
+ 	property.c quota.c ref_count.c regexpr.c server.c storage.c streams.c str_intern.c \
+-	sym_table.c tasks.c timers.c unparse.c utils.c verbs.c version.c
++	sym_table.c tasks.c timers.c unparse.c utils.c verbs.c version.c \
++        bg_name_lookup.c
+ 
+ OPT_NET_SRCS = net_single.c net_multi.c \
+ 	net_mp_selct.c net_mp_poll.c net_mp_fake.c \
+@@ -498,3 +499,6 @@
+ client_sysv.o: client_sysv.c my-fcntl.h config.h my-signal.h \
+  my-stdio.h my-stdlib.h my-string.h my-types.h my-stat.h my-unistd.h \
+  options.h
++bg_name_lookup.o : bg_name_lookup.c tasks.h structures.h functions.h \
++ utils.h list.h my-in.h log.h exceptions.h net_multi.h storage.h \
++ server.h
+diff -Nur MOO-1.8.1-old/bf_register.h MOO-1.8.1-bg/bf_register.h
+--- MOO-1.8.1-old/bf_register.h	Mon Dec 14 08:17:29 1998
++++ MOO-1.8.1-bg/bf_register.h	Sat Dec  9 21:54:38 2000
+@@ -27,6 +27,9 @@
+ extern void register_server(void);
+ extern void register_tasks(void);
+ extern void register_verbs(void);
++/* bg_name_lookup */
++extern void register_name_lookup(void);
++/* !bg_name_lookup */
+ 
+diff -Nur MOO-1.8.1-old/bg_name_lookup.c MOO-1.8.1-bg/bg_name_lookup.c
+--- MOO-1.8.1-old/bg_name_lookup.c	Wed Dec 31 19:00:00 1969
++++ MOO-1.8.1-bg/bg_name_lookup.c	Sat Dec  9 23:41:17 2000
+@@ -0,0 +1,823 @@
++#include <errno.h>
++#include <signal.h>
++#include <netdb.h>      /* gethostby{name,addr}() */
++#include <unistd.h>     /* write(), read(), sleep(), alarm() */
++#include <stdlib.h>     /* malloc(), free() */
++#include <netinet/in.h> /* inet_ntoa() */
++#include <arpa/inet.h>  /* ditto */
++
++#include "tasks.h"
++#include "structures.h"
++#include "functions.h"
++#include "utils.h"
++#include "list.h"
++#include "my-in.h"
++
++#include "log.h"        /* errlog() */
++#include "exceptions.h" /* panic() */
++#include "net_multi.h"  /* network_{,un}register_fd() */
++#include "storage.h"    /* str_dup() */
++#include "server.h"     /* set_server_cmdline() */
++
++struct async_name_lookup_info
++{
++  enum { ASYNC_FROM_ADDR, ASYNC_FROM_NAME } kind;
++ 
++  unsigned timeout;
++  unsigned started;
++ 
++  union
++  {
++    char *name;
++    struct in_addr address;
++  } u;
++ 
++  pid_t pid;
++  int pipe_fd;
++ 
++  vm the_vm;
++ 
++  struct async_name_lookup_info *next;
++};
++
++struct async_request /* Same as name_lookup.c's struct request */
++{
++  enum { REQ_FROM_ADDR, REQ_FROM_NAME } kind;
++
++  unsigned timeout;
++
++  union
++  {
++    unsigned length;
++    /* struct sockaddr_in address; Why? */
++    struct in_addr address;
++  } u;
++};
++
++struct async_reply
++{
++  enum { AR_SUCCESS, AR_FAILURE } success;
++ 
++  enum error error;
++ 
++  int num_aliases;
++  int num_addresses;
++};
++ 
++typedef struct async_reply async_reply;
++typedef struct async_request async_request;
++
++struct async_name_lookup_info *async_name_lookup_info = 0;
++int                            async_name_lookup_len  = 0;
++
++static task_enum_action lookup_task_queue_enumerator(task_closure closure, void *data);
++static void async_name_lookup_readable(int fd, struct async_name_lookup_info *info_ptr);
++static struct async_name_lookup_info *dequeue_lookup_task(struct async_name_lookup_info *info_ptr);
++
++static struct async_name_lookup_info *async_lookup_from_name(const char *name, unsigned timeout);
++static struct async_name_lookup_info *async_lookup_from_addr(struct in_addr addr, unsigned timeout);
++
++static void async_lookup_from_addr_child(int to_parent, int from_parent);
++static void async_lookup_from_name_child(int to_parent, int from_parent);
++
++static void async_child_catch_alarm(int sig);
++
++/*** Utils ***/
++
++static int  /* Shamelessly stolen from name_lookup.c */
++robust_read(int fd, void *buffer, int len)
++{
++    int count;
++ 
++    do {
++        count = read(fd, buffer, len);
++    } while (count == -1 && errno == EINTR);
++ 
++    return count;
++} 
++
++static inline int
++robust_write(int fd, void *buffer, int len)
++{
++  int ret;
++
++  while (((ret = write(fd, buffer, len)) == -1) && (errno == EINTR))
++    ;
++
++  return ret;
++}
++
++/* Writes the string length followed by the string to an fd.
++ */
++static inline int
++string_write(int fd, char *str)
++{
++  int    ret;
++  size_t size;
++
++  size = strlen(str);
++  
++  ret = robust_write(fd, &size, sizeof(size));
++  if (ret != sizeof(size)) return ret;
++
++  ret = robust_write(fd, str, size);
++  return ret;
++}
++
++/* Reads a string length followed by a string.
++ * Returns NULL on error. Otherwise caller should free().
++ */
++static inline char *
++string_read(int fd)
++{
++  int ret;
++  size_t size;
++  char *str;
++
++  ret = robust_read(fd, &size, sizeof(size));
++  if (ret != sizeof(size)) return NULL;
++
++  str = malloc(size+1);
++  if (str == NULL) panic("STRING_READ: Out of memory.\n");
++
++  ret = robust_read(fd, str, size);
++  if (ret != size)
++  {
++    free(str);
++    return NULL;
++  }
++
++  str[size] = '\0';
++  return str;
++}
++
++
++/* Task queue stuff */
++
++
++/* Enumerator for custom task queue. Target of register_task_queue().
++ */
++static task_enum_action
++lookup_task_queue_enumerator(task_closure closure, void *data)
++{
++  int x;
++  struct async_name_lookup_info *info_ptr;
++  task_enum_action tea;
++  static const char status[] = "name_lookup()";
++ 
++  info_ptr = async_name_lookup_info;
++
++  for (x=1; x<=async_name_lookup_len; x++)
++  {
++    if (!info_ptr)
++      panic("LOOKUP_TASK_QUEUE_ENUMERATOR: Ran off end of linked list!");
++ 
++    tea = (*closure)(info_ptr->the_vm, status, data);
++ 
++    if (tea == TEA_KILL)
++    {
++      errlog("LOOKUP_TASK_QUEUE_ENUMERATOR: TEA_KILL\n");
++      dequeue_lookup_task(info_ptr);
++    }
++ 
++    if (tea != TEA_CONTINUE)
++      return tea;
++ 
++    info_ptr=info_ptr->next;
++  }
++ 
++  return TEA_CONTINUE;
++} 
++
++
++static enum error
++enqueue_lookup_task(vm the_vm, struct async_name_lookup_info *info_ptr)
++{
++  struct async_name_lookup_info **info_walk;
++
++  network_register_fd(info_ptr->pipe_fd, async_name_lookup_readable, NULL, info_ptr);
++  info_ptr->the_vm = the_vm;
++
++  /* Easier to throw them on the beginning, but oh well */
++  info_walk = &async_name_lookup_info;
++  while (*info_walk)
++  {
++    info_walk=&((*info_walk)->next);
++  }
++ 
++  *info_walk = info_ptr;
++
++  async_name_lookup_len++;
++ 
++  return E_NONE;
++}
++
++
++/* Scans the name lookup queue for the pointer we are given, and deletes it
++ * from the list. Returns a pointer to the next item in the list.
++ */
++static struct async_name_lookup_info *
++dequeue_lookup_task(struct async_name_lookup_info *info_ptr)
++{
++  struct async_name_lookup_info **info_walk;
++  int x=0;
++  int cleaned=0;
++ 
++  network_unregister_fd(info_ptr->pipe_fd);
++  close(info_ptr->pipe_fd);
++ 
++  for (info_walk=&async_name_lookup_info; *info_walk; info_walk=&((*info_walk)->next))
++  {
++    if (*info_walk == info_ptr)
++    {
++      struct async_name_lookup_info *next;
++
++      next = (*info_walk)->next; 
++      free(*info_walk);
++      *info_walk = next;
++      cleaned = 1;
++      break;
++    }
++ 
++    if (++x > async_name_lookup_len)
++      panic("DEQUEUE_LOOKUP_TASK: Queue is longer than it should be. :-(");
++  }
++ 
++  if (!cleaned)
++    panic("DEQUEUE_LOOKUP_TASK: Failed to clean up.");
++ 
++  async_name_lookup_len--;
++ 
++  return *info_walk;
++}
++
++
++/* Callback set in place with network_register_fd().
++ */
++static void
++async_name_lookup_readable(int fd, struct async_name_lookup_info *info_ptr)
++{
++  async_reply rep;
++  Var r;
++ 
++  char *name;
++ 
++  if ((robust_read(info_ptr->pipe_fd, &rep, sizeof(rep)) != sizeof(rep)))
++  {
++    /* fd was probably closed as child died */
++    r.type  = TYPE_ERR;
++    r.v.err = E_VARNF;
++  }
++  else if (rep.success == AR_FAILURE)
++  {
++    /* Child reported an error, just return that */
++    r.type  = TYPE_ERR;
++    r.v.err = rep.error;
++  }
++  else if ((name = string_read(fd)) == NULL)
++  {
++    /* fd was probably closed as child died */
++    r.type  = TYPE_ERR;
++    r.v.err = E_VARNF;
++  }
++  else
++  {
++    int x;
++    char          **alias_list;
++    struct in_addr *addr_list;
++
++    if ((alias_list = calloc(rep.num_aliases, sizeof(alias_list[0]))) == NULL)
++    {
++      panic("ASYNC_NAME_LOOKUP_READABLE: Out of memory\n");
++    }
++
++    if ((addr_list = calloc(rep.num_addresses, sizeof(struct in_addr))) == NULL)
++    {
++      panic("ASYNC_NAME_LOOKUP_READABLE: Out of memory\n");
++    }
++
++    /* Read the alias ptrs into our array */
++    for (x=0; x<rep.num_aliases; x++)
++    {
++      alias_list[x] = string_read(info_ptr->pipe_fd);
++      /* oklog("Alias %d: %s\n", x, alias_list[x]); */
++      /* Should do something smarter on error */
++      if (alias_list[x] == NULL)
++        panic("ASYNC_NAME_LOOKUP_READABLE: Couldn't read alias.\n");
++    }
++
++    /* Read the addrs */
++    for (x=0; x<rep.num_addresses; x++)
++    {
++      /* Should do something smarter on error */
++      if (robust_read(info_ptr->pipe_fd, &(addr_list[x].s_addr), sizeof(addr_list[0].s_addr)) != sizeof(addr_list[0].s_addr))
++        panic("ASYNC_NAME_LOOKUP_READABLE: Couldn't read address.\n");
++      /* oklog("Address %d: %s\n", x, inet_ntoa(addr_list[x])); */
++    }
++
++    /* Yay, return successful result */
++    r = new_list(3);
++
++    r.v.list[1].type  = TYPE_STR;
++    r.v.list[1].v.str = str_dup(name);
++
++    r.v.list[2] = new_list(rep.num_aliases);
++    for (x=0; x<rep.num_aliases; x++)
++    {
++      r.v.list[2].v.list[x+1].type  = TYPE_STR;
++      r.v.list[2].v.list[x+1].v.str = str_dup(alias_list[x]);
++    }
++
++    r.v.list[3] = new_list(rep.num_addresses);
++    for (x=0; x<rep.num_addresses; x++)
++    {
++      unsigned char *y=(unsigned char *) &(addr_list[x].s_addr);
++
++      r.v.list[3].v.list[x+1] = new_list(4);
++      r.v.list[3].v.list[x+1].v.list[1].type  = TYPE_INT;
++      r.v.list[3].v.list[x+1].v.list[1].v.num = (int) *y++;
++      r.v.list[3].v.list[x+1].v.list[2].type  = TYPE_INT;
++      r.v.list[3].v.list[x+1].v.list[2].v.num = (int) *y++;
++      r.v.list[3].v.list[x+1].v.list[3].type  = TYPE_INT;
++      r.v.list[3].v.list[x+1].v.list[3].v.num = (int) *y++;
++      r.v.list[3].v.list[x+1].v.list[4].type  = TYPE_INT;
++      r.v.list[3].v.list[x+1].v.list[4].v.num = (int) *y++;
++    }
++
++    /* Free all our stuff */
++    free(name);
++    free(alias_list);
++    free(addr_list);
++  }
++ 
++  resume_task(info_ptr->the_vm, r);
++ 
++  /* Clean up */
++  dequeue_lookup_task(info_ptr);
++ 
++  return;
++}
++
++
++/*** Builtin function stuff ***/
++ 
++
++/* bf_name_lookup(str/list addr, int timeout) => {str name, list aliases, list addresses}
++ * E_PERM    - Not a wizard.
++ * E_RECMOVE - Problem starting name lookup.
++ * E_VARNF   - Name lookup died. (Timeout)
++ * Results from gethostbyname():
++ * E_PROPNF  - Host was not found.
++ * E_MAXREC  - Temporary error, try again.
++ * E_INVIND  - Host exists but has no address information.
++ * E_VERBNF  - Unrecoverable error.
++ */
++static package
++bf_name_lookup(Var arglist, Byte next, void *vdata, Objid progr)
++{
++  Var r;  /* probably unneeded */
++  struct async_name_lookup_info *info_ptr;
++ 
++  int timeout = arglist.v.list[2].v.num;
++ 
++  if (!is_wizard(progr))
++  {
++    free_var(arglist);
++    return make_error_pack(E_PERM);
++  }
++ 
++  switch (arglist.v.list[1].type)
++  {
++  case TYPE_STR:
++    if ((info_ptr = async_lookup_from_name(arglist.v.list[1].v.str, timeout)) == NULL)
++    {
++      free_var(arglist);
++      return make_error_pack(E_RECMOVE);  /* Problem starting or talking to child */
++    }
++    else
++    {
++      free_var(arglist);
++      return make_suspend_pack(enqueue_lookup_task, info_ptr);
++    }
++ 
++    break;
++  case TYPE_LIST:
++    if (arglist.v.list[1].v.list[0].v.num != 4)
++    {
++      free_var(arglist);
++      return make_error_pack(E_INVARG);
++    }
++    else
++    {
++      int x;
++      struct in_addr tmp_addr;
++      unsigned char *y = (unsigned char *) &(tmp_addr.s_addr);
++
++      /* We have a list of length 4. Turn it into an IP. */
++      for (x=1; x<=4; x++)
++      {
++        if ((arglist.v.list[1].v.list[x].type != TYPE_INT) ||
++            (arglist.v.list[1].v.list[x].v.num < 0)        ||
++            (arglist.v.list[1].v.list[x].v.num > 255))
++        {
++          free_var(arglist);
++          return make_error_pack(E_INVARG);
++        }
++        else
++          *y++ = (unsigned char) arglist.v.list[1].v.list[x].v.num;
++      }
++
++      free_var(arglist); /* We're done with them at this point */
++
++      /* Try to look it up. */
++      if ((info_ptr = async_lookup_from_addr(tmp_addr, timeout)) == NULL)
++        return make_error_pack(E_RECMOVE);  /* Problem starting or talking to child */
++      else
++        return make_suspend_pack(enqueue_lookup_task, info_ptr);
++    }
++
++    break;
++  default:
++    free_var(arglist);
++    return make_error_pack(E_TYPE);
++    break;
++  }
++ 
++  /* Hmm... */
++  errlog("BF_NAME_LOOKUP: How did we get here?\n");
++
++  r.type = TYPE_INT;
++  r.v.num = 0;
++
++  free_var(arglist);
++  return make_var_pack(r);
++}
++
++
++
++/* bf_name_lookups() => {{str/list addr, int timeout, int started, int task_id}, ...}
++ */
++static package
++bf_name_lookups(Var arglist, Byte next, void *vdata, Objid progr)
++{
++  Var r;
++  int x;
++  struct async_name_lookup_info *info_ptr;
++ 
++  if (!is_wizard(progr))
++  {
++    free_var(arglist);
++    return make_error_pack(E_PERM);
++  }
++ 
++  info_ptr = async_name_lookup_info;
++  r = new_list(async_name_lookup_len);
++ 
++  for (x=1; x<=async_name_lookup_len; x++)
++  {
++    r.v.list[x] = new_list(4);
++ 
++    if (!info_ptr)
++      panic("BF_NAME_LOOKUPS: Ran off end of linked list!");
++ 
++    r.v.list[x].v.list[1].type = TYPE_STR;
++    r.v.list[x].v.list[1].v.str = str_dup(info_ptr->u.name);
++ 
++    r.v.list[x].v.list[2].type = TYPE_INT;
++    r.v.list[x].v.list[2].v.num = info_ptr->timeout;
++ 
++    r.v.list[x].v.list[3].type = TYPE_INT;
++    r.v.list[x].v.list[3].v.num = info_ptr->started;
++ 
++    r.v.list[x].v.list[4].type = TYPE_INT;
++    r.v.list[x].v.list[4].v.num = info_ptr->the_vm->task_id;
++ 
++    info_ptr = info_ptr->next;
++  }
++ 
++  free_var(arglist);
++  return make_var_pack(r);
++} 
++
++
++void
++register_name_lookup()
++{ 
++  register_task_queue(lookup_task_queue_enumerator);
++  (void) register_function("name_lookup", 2, 2, bf_name_lookup, TYPE_ANY, TYPE_INT);
++  (void) register_function("name_lookups", 0, 0, bf_name_lookups);
++}
++
++
++/*** Interface with child stuff ***/
++
++
++/* Hmm.
++ * We probably inherit signal handlers?
++ * And we should probably close() the network fd's?
++ */
++static pid_t spawn_async_lookup(void (*child_proc) (int to_parent, int from_parent),
++                                 int *to_child, int *from_child)
++{
++  int pipe_to_child[2], pipe_from_child[2];
++  pid_t pid;
++ 
++  if (pipe(pipe_to_child) < 0) {
++    log_perror("SPAWN_ASYNC_LOOKUP: Couldn't create first pipe");
++  } else if (pipe(pipe_from_child) < 0) {
++    log_perror("SPAWN_ASYNC_LOOKUP: Couldn't create second pipe");
++    close(pipe_to_child[0]);
++    close(pipe_to_child[1]);
++  } else if ((pid = fork()) < 0) {
++    log_perror("SPAWN_ASYNC_LOOKUP: Couldn't fork name lookup process");
++    close(pipe_to_child[0]);
++    close(pipe_to_child[1]);
++    close(pipe_from_child[0]);
++    close(pipe_from_child[1]);
++  } else if (pid != 0) {      /* parent */
++ 
++    close(pipe_to_child[0]);
++    close(pipe_from_child[1]);
++    *to_child = pipe_to_child[1];
++    *from_child = pipe_from_child[0];
++ 
++    return pid;
++  } else {                   /* child */
++    close(pipe_to_child[1]);
++    close(pipe_from_child[0]);
++ 
++    signal(SIGALRM, async_child_catch_alarm);
++ 
++    (*child_proc) (pipe_from_child[1], pipe_to_child[0]);
++    exit(0);
++  }
++ 
++  return 0;
++} 
++
++
++static struct async_name_lookup_info *
++async_lookup_from_name(const char *name, unsigned timeout)
++{
++  struct async_name_lookup_info *info_new;
++ 
++  async_request req;
++
++  int pid;
++  int to_child, from_child;
++ 
++ 
++  if ((info_new=malloc(sizeof(struct async_name_lookup_info))) == NULL)
++  {
++    errlog("ASYNC_LOOKUP_FROM_NAME: Malloc failed.\n");
++    return NULL;
++  }
++ 
++  pid = spawn_async_lookup(async_lookup_from_name_child, &to_child, &from_child);
++  if (!pid)
++  {
++    errlog("ASYNC_LOOKUP_FROM_NAME: Could not spawn child!\n");
++    free(info_new);
++    return NULL;
++  }
++ 
++  req.kind     = REQ_FROM_NAME;
++  req.timeout  = timeout;
++  req.u.length = strlen(name);
++ 
++  if (robust_write(to_child, &req, sizeof(req)) == -1)
++  {
++    log_perror("ASYNC_LOOKUP_FROM_NAME: Couldn't write request to child");
++    free(info_new);
++    return NULL;
++  }
++ 
++  if (robust_write(to_child, name, req.u.length) == -1)
++  {
++    log_perror("ASYNC_LOOKUP_FROM_NAME: Couldn't write name to child");
++    free(info_new);
++    return NULL;
++  }
++ 
++  close(to_child);
++ 
++  info_new->timeout = timeout;
++  info_new->started = time(NULL);
++  info_new->u.name  = str_dup(name);
++  info_new->pid     = pid;
++  info_new->pipe_fd = from_child;
++  info_new->next    = 0;
++ 
++  return info_new;
++} 
++
++
++static struct async_name_lookup_info *
++async_lookup_from_addr(struct in_addr addr, unsigned timeout)
++{
++  struct async_name_lookup_info *info_new;
++ 
++  async_request req;
++
++  int pid;
++  int to_child, from_child;
++
++ 
++  if ((info_new=malloc(sizeof(struct async_name_lookup_info))) == NULL)
++  {
++    errlog("ASYNC_LOOKUP_FROM_ADDR: Malloc failed.\n");
++    return NULL;
++  }
++ 
++  pid = spawn_async_lookup(async_lookup_from_addr_child, &to_child, &from_child);
++  if (!pid)
++  {
++    errlog("ASYNC_LOOKUP_FROM_ADDR: Could not spawn child!\n");
++    free(info_new);
++    return NULL;
++  }
++ 
++  req.kind             = REQ_FROM_ADDR;
++  req.timeout          = timeout;
++  req.u.address.s_addr = addr.s_addr;
++ 
++  if (robust_write(to_child, &req, sizeof(req)) == -1)
++  {
++    log_perror("ASYNC_LOOKUP_FROM_ADDR: Couldn't write request to child");
++    free(info_new);
++    return NULL;
++  }
++
++  close(to_child);
++ 
++  info_new->timeout          = timeout;
++  info_new->started          = time(NULL);
++  info_new->u.address.s_addr = addr.s_addr;
++  info_new->pid              = pid;
++  info_new->pipe_fd          = from_child;
++  info_new->next             = 0;
++
++  return info_new;
++} 
++
++
++/*** Runs in child ***/
++
++/* Name lookup process timed out. Give up.
++ */
++static void
++async_child_catch_alarm(int sig)
++{
++  _exit(1);
++}
++
++
++/* Called from async_lookup_from_{name,addr}_child.
++ * Figures out what our name lookup answer was, and tells the parent about it.
++ */
++static void process_lookup_answer(int to_parent, struct hostent *answer)
++{
++  async_reply   rep;
++
++  if (answer == NULL)
++  {
++    /* Report failure */
++    rep.success = AR_FAILURE;
++ 
++    switch (h_errno)
++    {
++    case HOST_NOT_FOUND:
++      rep.error   = E_PROPNF;
++      break;
++    case TRY_AGAIN:
++      rep.error   = E_MAXREC;
++      break;
++    case NO_DATA:
++      rep.error   = E_INVIND;
++      break;
++    default:
++      rep.error   = E_VERBNF;
++      break;
++    }
++ 
++    write(to_parent, &rep, sizeof(rep));
++ 
++    _exit(1);
++  }
++  else
++  {
++    int x;
++
++    char ** addr_list = answer->h_addr_list;
++    char **alias_list = answer->h_aliases;
++
++ 
++    /* Report success */
++    rep.success = AR_SUCCESS;
++    rep.error   = E_NONE;
++ 
++    /* Count the number of aliases */
++    for (x=0; alias_list[x]; x++)
++      ;
++    rep.num_aliases = x;
++ 
++    /* Count the number of addresses */
++    for (x=0; addr_list[x]; x++)
++      ;
++    rep.num_addresses = x;
++    
++    /* sleep(10); */
++    robust_write(to_parent, &rep, sizeof(rep));
++
++    /* Write the CNAME */
++    string_write(to_parent, answer->h_name);
++
++    /* Write the list of aliases */
++    for (x=0; x < rep.num_aliases; x++)
++      string_write(to_parent, alias_list[x]);
++
++    /* Write the list of addresses */
++    for (x=0; x < rep.num_addresses; x++)
++      robust_write(to_parent, addr_list[x], answer->h_length);
++  }
++
++}
++
++
++static void async_lookup_from_name_child(int to_parent, int from_parent)
++{
++  async_request req;
++  char *name, *cmdline;
++  struct hostent *answer;
++ 
++  if (robust_read(from_parent, &req, sizeof(req)) != sizeof(req)) {
++    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Read of request failed.\n");
++    _exit(1);
++  }
++  else if (req.kind != REQ_FROM_NAME) {
++    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Unexpected request kind.\n");
++    _exit(1);
++  }
++  else if ((name = malloc(req.u.length + 1)) == NULL) {
++    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Out of memory\n");
++    _exit(1);
++  }
++  else if (robust_read(from_parent, name, req.u.length) != req.u.length) {
++    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Read of name failed.\n");
++    _exit(1);
++  }
++ 
++  name[req.u.length]='\0';
++
++  /* Set the command line while we're doing our lookup */
++  cmdline=malloc(50+req.u.length);
++  if (cmdline != NULL)
++  {
++    sprintf(cmdline, "(MOO async name lookup: %s)", name);
++    set_server_cmdline(cmdline);
++    free(cmdline);
++  }
++ 
++  alarm(req.timeout);
++ 
++  answer = gethostbyname(name);
++
++  alarm(0);
++
++  process_lookup_answer(to_parent, answer);
++
++  return;
++}   
++
++
++static void async_lookup_from_addr_child(int to_parent, int from_parent)
++{
++  async_request req;
++  char cmdline[50];
++  struct hostent *answer;
++ 
++  if (robust_read(from_parent, &req, sizeof(req)) != sizeof(req)) {
++    errlog("ASYNC_LOOKUP_FROM_ADDR_CHILD: Read of request failed.\n");
++    _exit(1);
++  }
++  else if (req.kind != REQ_FROM_ADDR) {
++    errlog("ASYNC_LOOKUP_FROM_ADDR_CHILD: Unexpected request kind.\n");
++    _exit(1);
++  }
++
++  /* Set the command line while we're doing our lookup */
++  sprintf(cmdline, "(MOO async name lookup: %s)", inet_ntoa(req.u.address));
++  set_server_cmdline(cmdline);
++ 
++  alarm(req.timeout);
++ 
++  answer = gethostbyaddr((void *) &(req.u.address.s_addr), sizeof(req.u.address.s_addr), AF_INET);
++
++  alarm(0);
++
++  process_lookup_answer(to_parent, answer);
++
++  return;
++}   
++
++
+diff -Nur MOO-1.8.1-old/db_file.c MOO-1.8.1-bg/db_file.c
+--- MOO-1.8.1-old/db_file.c	Mon Dec 14 08:17:33 1998
++++ MOO-1.8.1-bg/db_file.c	Sat Dec  9 21:49:53 2000
+@@ -561,7 +561,9 @@
+     reset_command_history();
+ #else
+     if (reason == DUMP_CHECKPOINT) {
+-	switch (fork_server("checkpointer")) {
++/* bg_name_lookup */
++        switch (fork_server("checkpointer", &checkpoint_pid)) {
++/* !bg_name_lookup */
+ 	case FORK_PARENT:
+ 	    reset_command_history();
+ 	    free_stream(s);
+diff -Nur MOO-1.8.1-old/functions.c MOO-1.8.1-bg/functions.c
+--- MOO-1.8.1-old/functions.c	Mon Dec 14 08:17:53 1998
++++ MOO-1.8.1-bg/functions.c	Sat Dec  9 21:50:34 2000
+@@ -55,6 +55,9 @@
+     register_server,
+     register_tasks,
+     register_verbs
++/* bg_name_lookup */
++    ,register_name_lookup
++/* !bg_name_lookup */
+ };
+ 
+ void
+Binary files MOO-1.8.1-old/moo and MOO-1.8.1-bg/moo differ
+diff -Nur MOO-1.8.1-old/net_bsd_tcp.c MOO-1.8.1-bg/net_bsd_tcp.c
+--- MOO-1.8.1-old/net_bsd_tcp.c	Mon Dec 14 08:18:27 1998
++++ MOO-1.8.1-bg/net_bsd_tcp.c	Sat Dec  9 23:20:46 2000
+@@ -165,7 +165,9 @@
+     }
+     *read_fd = *write_fd = fd;
+     stream_printf(s, "%s, port %d",
+-		  lookup_name_from_addr(&address, timeout),
++/* bg_name_lookup */
++                  inet_ntoa(address. sin_addr),
++/* !bg_name_lookup */
+ 		  (int) ntohs(address.sin_port));
+     *name = reset_stream(s);
+     return PA_OKAY;
+diff -Nur MOO-1.8.1-old/server.c MOO-1.8.1-bg/server.c
+--- MOO-1.8.1-old/server.c	Tue Dec 29 01:56:32 1998
++++ MOO-1.8.1-bg/server.c	Sat Dec  9 21:46:14 2000
+@@ -48,6 +48,10 @@
+ 
+ #include "execute.h"
+ 
++/* bg_name_lookup */
++pid_t checkpoint_pid = 0;
++/* !bg_name_lookup */
++
+ static pid_t parent_pid;
+ int in_child = 0;
+ 
+@@ -224,7 +228,9 @@
+ }
+ 
+ enum Fork_Result
+-fork_server(const char *subtask_name)
++/* bg_name_lookup - Throw pid in *child_pid if child_pid not NULL */
++fork_server(const char *subtask_name, pid_t *child_pid)
++/* !bg_name_lookup */
+ {
+     pid_t pid;
+     Stream *s = new_stream(100);
+@@ -241,7 +247,13 @@
+ 	in_child = 1;
+ 	return FORK_CHILD;
+     } else
+-	return FORK_PARENT;
++/* bg_name_lookup */
++    {
++        if (child_pid != NULL)
++          *child_pid=pid;
++        return FORK_PARENT;
++    }
++/* !bg_name_lookup */
+ }
+ 
+ static void
+@@ -286,23 +298,42 @@
+     /* (Void *) casts to avoid warnings on systems that mis-declare the
+      * argument type.
+      */
++/* bg_name_lookup */
++    pid_t pid;
++ 
++#   define CHECKPID                                   \
++    if (pid && pid == checkpoint_pid)                 \
++    {                                                 \
++      /* 1 = failure, 2 = success */                  \
++      checkpoint_finished = (status == 0) + 1;        \
++    }                                                 \
++ 
+ #if HAVE_WAITPID
+-    while (waitpid(-1, (void *) &status, WNOHANG) > 0);
++    do {
++      pid = waitpid(-1, (void *) &status, WNOHANG);
++      CHECKPID;
++    } while (pid > 0);
+ #else
+ #if HAVE_WAIT3
+-    while (wait3((void *) &status, WNOHANG, 0) >= 0);
++    do {
++      pid = wait3((void *) &status, WNOHANG, 0);
++      CHECKPID;
++    } while (pid > 0)
+ #else
+ #if HAVE_WAIT2
+-    while (wait2((void *) &status, WNOHANG) >= 0);
++    do {
++      pid = wait2((void *) &status, WNOHANG);
++      CHECKPID;
++    } while (pid > 0)
+ #else
+-    wait((void *) &status);
++    pid = wait((void *) &status);
++    CHECKPID;
+ #endif
+ #endif
+ #endif
+-
++ 
+     signal(sig, child_completed_signal);
+-
+-    checkpoint_finished = (status == 0) + 1;	/* 1 = failure, 2 = success */
++/* !bg_name_lookup */
+ }
+ 
+ static void
+diff -Nur MOO-1.8.1-old/server.h MOO-1.8.1-bg/server.h
+--- MOO-1.8.1-old/server.h	Mon Dec 14 08:18:58 1998
++++ MOO-1.8.1-bg/server.h	Sat Dec  9 21:40:52 2000
+@@ -26,6 +26,10 @@
+ #ifndef Server_H
+ #define Server_H 1
+ 
++/* bg_name_lookup */
++#include <sys/types.h> /* pid_t */
++/* !bg_name_lookup */
++
+ #include "my-stdio.h"
+ 
+ #include "config.h"
+@@ -148,7 +152,11 @@
+ enum Fork_Result {
+     FORK_PARENT, FORK_CHILD, FORK_ERROR
+ };
+-extern enum Fork_Result fork_server(const char *subtask_name);
++
++/* bg_name_lookup */
++extern pid_t checkpoint_pid;
++extern enum Fork_Result fork_server(const char *subtask_name, pid_t *child_pid);
++/* !bg_name_lookup */
+ 
+ extern void player_connected(Objid old_id, Objid new_id,
+ 			     int is_newly_created);
diff -Nur d20050324/projects/moo/src/BG_NAME_LOOKUP.txt d20050327/projects/moo/src/BG_NAME_LOOKUP.txt
--- d20050324/projects/moo/src/BG_NAME_LOOKUP.txt	1969-12-31 19:00:00.000000000 -0500
+++ d20050327/projects/moo/src/BG_NAME_LOOKUP.txt	2005-03-27 23:56:21.000000000 -0500
@@ -0,0 +1,106 @@
+The MOO programmer's manual has this to say about name lookups:
+--- snip ---
+Accepting and Initiating Network Connections
+--------------------------------------------
+ 
+   When the server first accepts a new, incoming network connection, it is
+given the low-level network address of computer on the other end.  It
+immediately attempts to convert this address into the human-readable host name
+that will be entered in the server log and returned by the `connection_name()'
+function.  This conversion can, for the TCP/IP networking configurations,
+involve a certain amount of communication with remote name servers, which can
+take quite a long time and/or fail entirely.  While the server is doing this
+conversion, it is not doing anything else at all; in particular, it it not
+responding to user commands or executing MOO tasks.
+ 
+   By default, the server will wait no more than 5 seconds for such a name
+lookup to succeed; after that, it behaves as if the conversion had failed,
+using instead a printable representation of the low-level address.  If the
+property `name_lookup_timeout' exists on `$server_options' and has an integer
+as its value, that integer is used instead as the timeout interval.
+--- snip ---
+
+I think a much better solution would be to handle these name server lookups in
+the background instead of "not doing anything else at all". That's what this
+patch is supposed to do.
+
+The idea is to no longer have the MOO attempt to do name lookups automatically
+when someone connects. Instead, a couple new builtin functions allow
+in-database code to explicitly request a name lookup. This also gives you the
+choice of not attempting to look up the name at all, for example if your MOO
+also serves web requests.
+
+This changes connection_name() to always return the IP address instead of the
+name, as if the automatic lookup had timed out.
+
+Added are name_lookup() which performs a name lookup, and name_lookups(), which
+returns a list of the name lookups that are in progress.
+
+The $server_options.name_lookup_timeout property is still useful. The
+open_network_connection() function still uses the old name lookup system, and
+needs a timeout.
+
+The queued_tasks() function now returns "name_lookup()" in place of the usual
+value that tells us at what time the verb will be done suspending.
+
+---
+
+Two new builtin functions:
+
+name_lookups() => {list info, ...}
+
+This function returns a list of background name lookups that are in progress.
+One `info' list is returned for each lookup. It has this format:
+
+{str/list address, int timeout, int started, int task_id}
+
+Address and timeout are the original values passed to the name_lookup() call.
+
+Started is the value of time() when the call took place.
+
+Task_id is the task id of the waiting program.
+
+name_lookup(str/list address, int timeout) =>
+ {str canonical-name, list aliases, list addresses}
+
+This function starts a new name lookup. The current verb suspends until the
+lookup is done, but the MOO server continues to process other commands.
+
+The address argument can be either a string such as "www.altavista.com", or a
+list describing an IP address. In one of these lists, the address
+192.168.0.14 becomes {192, 168, 0, 14}.
+
+The timeout arg is the number of seconds before this name lookup should be
+abandoned.
+
+For the return value, canonical-name is the proper name that was found.
+
+Aliases is a list of strings, each one giving an alternate name.
+
+Addresses is a list of lists, each one giving an IP address as described above.
+
+Both of these functions will raise E_PERM if you are not a wizard. 
+
+The name_lookup() function can also raise:
+E_RECMOVE - Problem starting name lookup.
+E_VARNF   - Timeout
+E_PROPNF  - Host was not found.
+E_MAXREC  - Temporary nameserver error, try again later.
+E_INVIND  - Host exists but has no address information.
+E_VERBNF  - Unrecoverable nameserver error.
+
+
+---
+
+#0:"bf_connection_name"   this none this
+"#0:z_connection_name last edited by Avalon on Thu Mar 24 00:59:24 2005 EST";
+try
+  p = args[1];
+  ip = $string_utils:connection_hostname(cn = connection_name(p));
+  name = name_lookup($list_utils:map_builtin($string_utils:explode(ip, "."),
+"tonum"), 5)[1];
+  ret = $string_utils:substitute(connection_name(p), {{ip, name}});
+  return ret;
+except v (ANY)
+  return connection_name(@args);
+endtry
diff -Nur d20050324/projects/moo/src/db_file.c d20050327/projects/moo/src/db_file.c
--- d20050324/projects/moo/src/db_file.c	2004-03-22 11:14:53.000000000 -0500
+++ d20050327/projects/moo/src/db_file.c	2005-03-27 23:56:21.000000000 -0500
@@ -561,7 +561,9 @@
     reset_command_history();
 #else
     if (reason == DUMP_CHECKPOINT) {
-	switch (fork_server("checkpointer")) {
+/* bg_name_lookup */
+        switch (fork_server("checkpointer", &checkpoint_pid)) {
+/* !bg_name_lookup */
 	case FORK_PARENT:
 	    reset_command_history();
 	    free_stream(s);
diff -Nur d20050324/projects/moo/src/functions.c d20050327/projects/moo/src/functions.c
--- d20050324/projects/moo/src/functions.c	2004-03-22 11:14:54.000000000 -0500
+++ d20050327/projects/moo/src/functions.c	2005-03-27 23:56:21.000000000 -0500
@@ -55,6 +55,9 @@
     register_server,
     register_tasks,
     register_verbs
+/* bg_name_lookup */
+    ,register_name_lookup
+/* !bg_name_lookup */
 };
 
 void
diff -Nur d20050324/projects/moo/src/Makefile.in d20050327/projects/moo/src/Makefile.in
--- d20050324/projects/moo/src/Makefile.in	2005-03-23 22:59:29.000000000 -0500
+++ d20050327/projects/moo/src/Makefile.in	2005-03-27 23:56:21.000000000 -0500
@@ -44,7 +44,8 @@
 	log.c malloc.c match.c md5.c name_lookup.c network.c net_mplex.c \
 	net_proto.c numbers.c objects.c parse_cmd.c pattern.c program.c \
 	property.c quota.c ref_count.c regexpr.c server.c storage.c streams.c str_intern.c \
-	sym_table.c tasks.c timers.c unparse.c utils.c verbs.c version.c ext-xml.c
+	sym_table.c tasks.c timers.c unparse.c utils.c verbs.c version.c \
+	ext-xml.c bg_name_lookup.c
 
 OPT_NET_SRCS = net_single.c net_multi.c \
 	net_mp_selct.c net_mp_poll.c net_mp_fake.c \
@@ -516,3 +520,6 @@
 client_sysv.o: client_sysv.c my-fcntl.h config.h my-signal.h \
  my-stdio.h my-stdlib.h my-string.h my-types.h my-stat.h my-unistd.h \
  options.h
+bg_name_lookup.o : bg_name_lookup.c tasks.h structures.h functions.h \
+ utils.h list.h my-in.h log.h exceptions.h net_multi.h storage.h \
+ server.h
diff -Nur d20050324/projects/moo/src/net_bsd_tcp.c d20050327/projects/moo/src/net_bsd_tcp.c
--- d20050324/projects/moo/src/net_bsd_tcp.c	2004-03-22 11:31:06.000000000 -0500
+++ d20050327/projects/moo/src/net_bsd_tcp.c	2005-03-27 23:56:21.000000000 -0500
@@ -189,7 +189,9 @@
     }
     *read_fd = *write_fd = fd;
     stream_printf(s, "%s, port %d",
-		  lookup_name_from_addr(&address, timeout),
+/* bg_name_lookup */
+                  inet_ntoa(address. sin_addr),
+/* !bg_name_lookup */
 		  (int) ntohs(address.sin_port));
     *name = reset_stream(s);
     return PA_OKAY;
diff -Nur d20050324/projects/moo/src/server.c d20050327/projects/moo/src/server.c
--- d20050324/projects/moo/src/server.c	2005-03-23 22:54:22.000000000 -0500
+++ d20050327/projects/moo/src/server.c	2005-03-27 23:56:21.000000000 -0500
@@ -48,6 +48,10 @@
 
 #include "execute.h"
 
+/* bg_name_lookup */
+pid_t checkpoint_pid = 0;
+/* !bg_name_lookup */
+
 static pid_t parent_pid;
 int in_child = 0;
 
@@ -224,7 +228,9 @@
 }
 
 enum Fork_Result
-fork_server(const char *subtask_name)
+/* bg_name_lookup - Throw pid in *child_pid if child_pid not NULL */
+fork_server(const char *subtask_name, pid_t *child_pid)
+/* !bg_name_lookup */
 {
     pid_t pid;
     Stream *s = new_stream(100);
@@ -241,7 +247,13 @@
 	in_child = 1;
 	return FORK_CHILD;
     } else
-	return FORK_PARENT;
+/* bg_name_lookup */
+    {
+        if (child_pid != NULL)
+          *child_pid=pid;
+        return FORK_PARENT;
+    }
+/* !bg_name_lookup */
 }
 
 static void
@@ -293,23 +305,42 @@
     /* (Void *) casts to avoid warnings on systems that mis-declare the
      * argument type.
      */
+/* bg_name_lookup */
+    pid_t pid;
+ 
+#   define CHECKPID                                   \
+    if (pid && pid == checkpoint_pid)                 \
+    {                                                 \
+      /* 1 = failure, 2 = success */                  \
+      checkpoint_finished = (status == 0) + 1;        \
+    }                                                 \
+ 
 #if HAVE_WAITPID
-    while (waitpid(-1, (void *) &status, WNOHANG) > 0);
+    do {
+      pid = waitpid(-1, (void *) &status, WNOHANG);
+      CHECKPID;
+    } while (pid > 0);
 #else
 #if HAVE_WAIT3
-    while (wait3((void *) &status, WNOHANG, 0) >= 0);
+    do {
+      pid = wait3((void *) &status, WNOHANG, 0);
+      CHECKPID;
+    } while (pid > 0)
 #else
 #if HAVE_WAIT2
-    while (wait2((void *) &status, WNOHANG) >= 0);
+    do {
+      pid = wait2((void *) &status, WNOHANG);
+      CHECKPID;
+    } while (pid > 0)
 #else
-    wait((void *) &status);
+    pid = wait((void *) &status);
+    CHECKPID;
 #endif
 #endif
 #endif
-
+ 
     signal(sig, child_completed_signal);
-
-    checkpoint_finished = (status == 0) + 1;	/* 1 = failure, 2 = success */
+/* !bg_name_lookup */
 }
 
 static void
diff -Nur d20050324/projects/moo/src/server.h d20050327/projects/moo/src/server.h
--- d20050324/projects/moo/src/server.h	2004-03-22 11:14:54.000000000 -0500
+++ d20050327/projects/moo/src/server.h	2005-03-27 23:56:21.000000000 -0500
@@ -26,6 +26,10 @@
 #ifndef Server_H
 #define Server_H 1
 
+/* bg_name_lookup */
+#include <sys/types.h> /* pid_t */
+/* !bg_name_lookup */
+
 #include "my-stdio.h"
 
 #include "config.h"
@@ -148,7 +152,11 @@
 enum Fork_Result {
     FORK_PARENT, FORK_CHILD, FORK_ERROR
 };
-extern enum Fork_Result fork_server(const char *subtask_name);
+
+/* bg_name_lookup */
+extern pid_t checkpoint_pid;
+extern enum Fork_Result fork_server(const char *subtask_name, pid_t *child_pid);
+/* !bg_name_lookup */
 
 extern void player_connected(Objid old_id, Objid new_id,
 			     int is_newly_created);
