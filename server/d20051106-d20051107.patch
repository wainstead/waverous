diff -Nur d20051106/projects/moo/src/db_io.c d20051107/projects/moo/src/db_io.c
--- d20051106/projects/moo/src/db_io.c	2004-03-22 11:14:53.000000000 -0500
+++ d20051107/projects/moo/src/db_io.c	2005-11-07 13:41:18.000000000 -0500
@@ -77,6 +77,7 @@
     count = 0;
     for (ptr = format; *ptr; ptr++) {
 	int c, n, *ip;
+	double *dp;
 	unsigned *up;
 	char *cp;
 
@@ -106,6 +107,14 @@
 		up = va_arg(args, unsigned *);
 		n = fscanf(input, "%u", up);
 		goto finish;
+	    case 'l':
+		if ((*(ptr+1)) && (*(ptr+1) == 'f')) {
+			ptr++;
+			dp = va_arg(args, double *);
+			n = fscanf(input, "%lf", dp);
+			goto finish;
+		}
+		panic("DBIO_SCANF: Unsupported directive!");
 	    case 'c':
 		cp = va_arg(args, char *);
 		n = fscanf(input, "%c", cp);
diff -Nur d20051106/projects/moo/src/execute.c d20051107/projects/moo/src/execute.c
--- d20051106/projects/moo/src/execute.c	2004-03-22 11:14:53.000000000 -0500
+++ d20051107/projects/moo/src/execute.c	2005-11-07 13:41:18.000000000 -0500
@@ -2448,13 +2448,18 @@
 static package
 bf_suspend(Var arglist, Byte next, void *vdata, Objid progr)
 {
-    static int seconds;
+    static double seconds;
     int nargs = arglist.v.list[0].v.num;
 
     if (nargs >= 1)
-	seconds = arglist.v.list[1].v.num;
+    {
+        if (arglist.v.list[1].type == TYPE_INT)
+	    seconds = (double) arglist.v.list[1].v.num;
+	else
+	    seconds = *arglist.v.list[1].v.fnum;
+    }
     else
-	seconds = -1;
+	seconds = -1.0;
     free_var(arglist);
 
     if (nargs >= 1 && seconds < 0)
@@ -2603,7 +2608,7 @@
 				      bf_call_function_write,
 				      TYPE_STR);
     register_function("raise", 1, 3, bf_raise, TYPE_ANY, TYPE_STR, TYPE_ANY);
-    register_function("suspend", 0, 1, bf_suspend, TYPE_INT);
+    register_function("suspend", 0, 1, bf_suspend, TYPE_NUMERIC);
     register_function("read", 0, 2, bf_read, TYPE_OBJ, TYPE_ANY);
 
     register_function("seconds_left", 0, 0, bf_seconds_left);
diff -Nur d20051106/projects/moo/src/net_mplex.h d20051107/projects/moo/src/net_mplex.h
--- d20051106/projects/moo/src/net_mplex.h	2004-03-22 11:14:54.000000000 -0500
+++ d20051107/projects/moo/src/net_mplex.h	2005-11-07 13:41:19.000000000 -0500
@@ -48,7 +48,7 @@
 				 * set, marked for writing.
 				 */
 
-extern int mplex_wait(unsigned timeout);
+extern int mplex_wait(struct timeval *timeout);
 				/* Wait until it is possible either to do the
 				 * appropriate kind of I/O on some descriptor
 				 * in the wait set or until `timeout' seconds
diff -Nur d20051106/projects/moo/src/net_mp_selct.c d20051107/projects/moo/src/net_mp_selct.c
--- d20051106/projects/moo/src/net_mp_selct.c	2004-03-22 11:14:54.000000000 -0500
+++ d20051107/projects/moo/src/net_mp_selct.c	2005-11-07 13:41:19.000000000 -0500
@@ -53,13 +53,14 @@
 }
 
 int
-mplex_wait(unsigned timeout)
+mplex_wait(struct timeval *timeout)
 {
-    struct timeval tv;
+    struct timeval tv;  /* Make a copy since select() might write to it */
     int n;
 
-    tv.tv_sec = timeout;
-    tv.tv_usec = 0;
+    if (timeout) {
+	tv = *timeout;
+    }
 
     n = select(max_descriptor + 1, (void *) &input, (void *) &output, 0, &tv);
 
diff -Nur d20051106/projects/moo/src/net_multi.c d20051107/projects/moo/src/net_multi.c
--- d20051106/projects/moo/src/net_multi.c	2005-05-19 12:31:06.000000000 -0400
+++ d20051107/projects/moo/src/net_multi.c	2005-11-07 13:41:19.000000000 -0500
@@ -587,7 +587,7 @@
 }
 
 int
-network_process_io(int timeout)
+network_process_io(struct timeval *timeout)
 {
     nhandle *h, *hnext;
     nlistener *l;
diff -Nur d20051106/projects/moo/src/network.h d20051107/projects/moo/src/network.h
--- d20051106/projects/moo/src/network.h	2004-03-22 11:32:06.000000000 -0500
+++ d20051107/projects/moo/src/network.h	2005-11-07 13:41:19.000000000 -0500
@@ -24,6 +24,8 @@
 #ifndef Network_H
 #define Network_H 1
 
+#include <sys/time.h>
+
 #include "config.h"
 #include "options.h"
 #include "structures.h"
@@ -147,7 +149,7 @@
 				 * `binary input mode'.
 				 */
 
-extern int network_process_io(int timeout);
+extern int network_process_io(struct timeval *timeout);
 				/* This is called at intervals to allow the
 				 * network to flush pending output, receive
 				 * pending input, and handle requests for new
diff -Nur d20051106/projects/moo/src/server.c d20051107/projects/moo/src/server.c
--- d20051106/projects/moo/src/server.c	2005-03-27 23:56:21.000000000 -0500
+++ d20051107/projects/moo/src/server.c	2005-11-07 13:41:19.000000000 -0500
@@ -477,12 +477,18 @@
 
     /* Now, we enter the main server loop */
     while (shutdown_message == 0) {
-	/* Check how long we have until the next task will be ready to run.
-	 * We only care about three cases (== 0, == 1, and > 1), so we can
-	 * map a `never' result from the task subsystem into 2.
-	 */
-	int task_seconds = next_task_start();
-	int seconds_left = task_seconds < 0 ? 2 : task_seconds;
+        struct timeval task_seconds;
+        int            any_tasks;
+
+        any_tasks = next_task_start(&task_seconds);
+
+        /* Set maximum timeout of 1 second if no tasks or if the next task is farther than 1 second away */
+        if ((!any_tasks) || (task_seconds.tv_sec > 0))
+        {
+          task_seconds.tv_sec  = 1;
+          task_seconds.tv_usec = 0;
+        }
+
 	shandle *h, *nexth;
 
 	if (checkpoint_requested != CHKPT_OFF) {
@@ -507,7 +513,7 @@
 	}
 #endif
 
-	if (!network_process_io(seconds_left ? 1 : 0) && seconds_left > 1)
+	if (!network_process_io(&task_seconds) && any_tasks)
 	    db_flush(FLUSH_ONE_SECOND);
 	else
 	    db_flush(FLUSH_IF_FULL);
diff -Nur d20051106/projects/moo/src/tasks.c d20051107/projects/moo/src/tasks.c
--- d20051106/projects/moo/src/tasks.c	2005-07-29 12:10:14.000000000 -0400
+++ d20051107/projects/moo/src/tasks.c	2005-11-07 13:41:19.000000000 -0500
@@ -15,6 +15,9 @@
     Pavel@Xerox.Com
  *****************************************************************************/
 
+#include <sys/time.h>
+#include <math.h>
+
 #include "my-string.h"
 #include "my-time.h"
 
@@ -30,6 +33,7 @@
 #include "list.h"
 #include "log.h"
 #include "match.h"
+#include "numbers.h"
 #include "options.h"
 #include "parse_cmd.h"
 #include "parser.h"
@@ -49,12 +53,12 @@
     activation a;
     Var *rt_env;
     int f_index;
-    time_t start_time;
+    struct timeval start_time;
 } forked_task;
 
 typedef struct suspended_task {
     vm the_vm;
-    time_t start_time;
+    struct timeval start_time;
     Var value;
 } suspended_task;
 
@@ -139,6 +143,121 @@
      ? ttt->t.forked.start_time \
      : ttt->t.suspended.start_time)
 
+static void
+double_to_timeval(double d, struct timeval *tv)
+{
+  double secs, usecs, frac;
+
+  frac = modf(d, &secs);
+  usecs = ((double) 1000000) * frac;
+
+  tv->tv_sec  = (long) secs;
+  tv->tv_usec = (long) usecs;
+
+  return;
+}
+
+static double
+timeval_to_double(struct timeval *tv)
+{
+  double r;
+
+  r  = tv->tv_sec;
+  r += tv->tv_usec / ((double) 1000000);
+
+  return r;
+}
+
+static int
+timeval_lt(struct timeval *tv1, struct timeval *tv2)
+/* Returns true if tv1 is less than tv2. If either arg is NULL, time 0 is assumed. */
+{
+  long secs1, usecs1;
+  long secs2, usecs2;
+
+  if (tv1 == NULL)
+  {
+    secs1  = 0;
+    usecs1 = 0;
+  }
+  else
+  {
+    secs1  = tv1->tv_sec;
+    usecs1 = tv1->tv_usec;
+  }
+
+  if (tv2 == NULL)
+  {
+    secs2  = 0;
+    usecs2 = 0;
+  }
+  else
+  {
+    secs2  = tv2->tv_sec;
+    usecs2 = tv2->tv_usec;
+  }
+
+  if (secs1 < secs2)
+    return 1;
+
+  if ((secs1 == secs2) && (usecs1 < usecs2))
+    return 1;
+
+  return 0;
+}
+
+static void
+timeval_add(struct timeval *result, struct timeval *tv1, struct timeval *tv2)
+/* Adds *tv1 and *tv2 and writes the result to *result. */
+/* Neither *tv1 nor *tv2 should have negative fields. */
+/* It's safe to have (result == tv1) || (result == tv2) */
+{
+  struct timeval sum;
+
+  sum.tv_sec  = tv1->tv_sec;
+  sum.tv_sec += tv2->tv_sec;
+
+  sum.tv_usec  = tv1->tv_usec;
+  sum.tv_usec += tv2->tv_usec;
+
+  if (sum.tv_usec >= 1000000)
+  {
+    /* Microsecond carry */
+    sum.tv_sec += sum.tv_usec / 1000000;
+    sum.tv_usec %= 1000000;
+  }
+
+  if ((sum.tv_sec < tv1->tv_sec) || (sum.tv_sec < tv2->tv_sec))
+  {
+    /* Seconds overflow */
+    sum.tv_sec = INT_MAX;
+  }
+
+  *result = sum;
+}
+
+static void
+timeval_sub(struct timeval *result, struct timeval *tv1, struct timeval *tv2)
+/* Subtracts *tv2 from *tv1 and stores the result in *result. */
+/* It's safe to have (result == tv1) || (result == tv2) */
+{
+  struct timeval diff;
+
+  diff.tv_sec  = tv1->tv_sec;
+  diff.tv_usec = tv1->tv_usec;
+
+  diff.tv_sec  -= tv2->tv_sec;
+  diff.tv_usec -= tv2->tv_usec;
+
+  if (diff.tv_usec < 0)
+  {
+    /* Microsecond borrow */
+    diff.tv_sec -= ((-diff.tv_usec) / 1000000) + 1;
+    diff.tv_usec = 1000000 - ((-diff.tv_usec) % 1000000);
+  }
+
+  *result = diff;
+}
 
 static void
 deactivate_tqueue(tqueue * tq)
@@ -777,21 +896,21 @@
 enqueue_waiting(task * t)
 {				/* either FORKED or SUSPENDED */
 
-    time_t start_time = GET_START_TIME(t);
+    struct timeval start_time = GET_START_TIME(t);
     Objid progr = (t->kind == TASK_FORKED
 		   ? t->t.forked.a.progr
 		   : progr_of_cur_verb(t->t.suspended.the_vm));
     tqueue *tq = find_tqueue(progr, 1);
 
     tq->num_bg_tasks++;
-    if (!waiting_tasks || start_time < GET_START_TIME(waiting_tasks)) {
+    if (!waiting_tasks || timeval_lt(&start_time, &GET_START_TIME(waiting_tasks))) {
 	t->next = waiting_tasks;
 	waiting_tasks = t;
     } else {
 	task *tt;
 
 	for (tt = waiting_tasks; tt->next; tt = tt->next)
-	    if (start_time < GET_START_TIME(tt->next))
+	    if (timeval_lt(&start_time, &GET_START_TIME(tt->next)))
 		break;
 	t->next = tt->next;
 	tt->next = t;
@@ -800,7 +919,7 @@
 
 static void
 enqueue_ft(Program * program, activation a, Var * rt_env,
-	   int f_index, time_t start_time, int id)
+	   int f_index, struct timeval start_time, int id)
 {
     task *t = (task *) mymalloc(sizeof(task), M_TASK);
 
@@ -843,10 +962,13 @@
 {
     int id;
     Var *rt_env;
+    struct timeval start_time;
 
     if (!check_user_task_limit(a.progr))
 	return E_QUOTA;
 
+    double_to_timeval((double) time(0) + after_seconds, &start_time);
+
     id = new_task_id();
     a.verb = str_ref(a.verb);
     a.verbname = str_ref(a.verbname);
@@ -857,7 +979,7 @@
 	a.rt_env[vid].v.num = id;
     }
     rt_env = copy_rt_env(a.rt_env, a.prog->num_var_names);
-    enqueue_ft(a.prog, a, rt_env, f_index, time(0) + after_seconds, id);
+    enqueue_ft(a.prog, a, rt_env, f_index, start_time, id);
 
     return E_NONE;
 }
@@ -865,21 +987,19 @@
 enum error
 enqueue_suspended_task(vm the_vm, void *data)
 {
-    int after_seconds = *((int *) data);
-    int now = time(0);
-    int when;
+    double after_seconds = *((double *) data);
+    struct timeval now;
+    struct timeval wait;
     task *t;
 
+    gettimeofday(&now, NULL);
+    double_to_timeval(after_seconds, &wait);
+
     if (check_user_task_limit(progr_of_cur_verb(the_vm))) {
 	t = mymalloc(sizeof(task), M_TASK);
 	t->kind = TASK_SUSPENDED;
 	t->t.suspended.the_vm = the_vm;
-	if (now + after_seconds < now)
-	    /* overflow or suspend `forever' code */
-	    when = INT32_MAX;
-	else
-	    when = now + after_seconds;
-	t->t.suspended.start_time = when;
+        timeval_add(&t->t.suspended.start_time, &now, &wait);
 	t->t.suspended.value = zero;
 
 	enqueue_waiting(t);
@@ -897,7 +1017,7 @@
 
     t->kind = TASK_SUSPENDED;
     t->t.suspended.the_vm = the_vm;
-    t->t.suspended.start_time = 0;	/* ready now */
+    double_to_timeval(0.0, &t->t.suspended.start_time);  /* ready now */
     t->t.suspended.value = value;
 
     enqueue_bg_task(tq, t);
@@ -952,31 +1072,48 @@
 }
 
 int
-next_task_start(void)
+next_task_start(struct timeval *tv)
 {
     tqueue *tq;
 
     for (tq = active_tqueues; tq; tq = tq->next)
 	if (tq->first_input != 0 || tq->first_bg != 0)
-	    return 0;
+        {
+            tv->tv_sec  = 0;
+            tv->tv_usec = 0;
+	    return 1;
+        }
 
     if (waiting_tasks != 0) {
-	int wait = (waiting_tasks->kind == TASK_FORKED
-		    ? waiting_tasks->t.forked.start_time
-		    : waiting_tasks->t.suspended.start_time) - time(0);
-	return (wait >= 0) ? wait : 0;
+        struct timeval wait;
+        struct timeval now;
+        struct timeval zero;
+
+        zero.tv_sec = 0;
+        zero.tv_usec = 0;
+
+        gettimeofday(&now, NULL);
+
+	timeval_sub(&wait, &(waiting_tasks->kind == TASK_FORKED
+		           ? waiting_tasks->t.forked.start_time
+	                   : waiting_tasks->t.suspended.start_time), &now);
+	*tv = timeval_lt(&wait, &zero) ? zero : wait;
+        return 1;
     }
-    return -1;
+
+    return 0;
 }
 
 void
 run_ready_tasks(void)
 {
     task *t, *next_t;
-    time_t now = time(0);
+    struct timeval now;
     tqueue *tq, *next_tq;
 
-    for (t = waiting_tasks; t && GET_START_TIME(t) <= now; t = next_t) {
+    gettimeofday(&now, NULL);
+
+    for (t = waiting_tasks; t && timeval_lt(&GET_START_TIME(t), &now); t = next_t) {
 	Objid progr = (t->kind == TASK_FORKED
 		       ? t->t.forked.a.progr
 		       : progr_of_cur_verb(t->t.suspended.the_vm));
@@ -1151,7 +1288,7 @@
 {
     int lineno = find_line_number(ft.program, ft.f_index, 0);
 
-    dbio_printf("0 %d %d %d\n", lineno, ft.start_time, ft.id);
+    dbio_printf("0 %d %lf %d\n", lineno, timeval_to_double(&ft.start_time), ft.id);
     write_activ_as_pi(ft.a);
     write_rt_env(ft.program->var_names, ft.rt_env, ft.program->num_var_names);
     dbio_write_forked_program(ft.program, ft.f_index);
@@ -1160,7 +1297,7 @@
 static void
 write_suspended_task(suspended_task st)
 {
-    dbio_printf("%d %d ", st.start_time, st.the_vm->task_id);
+    dbio_printf("%lf %d ", timeval_to_double(&st.start_time), st.the_vm->task_id);
     dbio_write_var(st.value);
     write_vm(st.the_vm);
 }
@@ -1238,21 +1375,23 @@
 	return 0;
     }
     for (; count > 0; count--) {
-	int first_lineno, id, old_size, st;
+	int first_lineno, id, old_size;
+        double st;
 	char c;
-	time_t start_time;
+	struct timeval start_time;
 	Program *program;
 	Var *rt_env, *old_rt_env;
 	const char **old_names;
 	activation a;
 
-	if (dbio_scanf("%d %d %d %d%c",
+	if (dbio_scanf("%d %d %lf %d%c",
 		       &dummy, &first_lineno, &st, &id, &c) != 5
 	    || c != '\n') {
 	    errlog("READ_TASK_QUEUE: Bad numbers, count = %d.\n", count);
 	    return 0;
 	}
-	start_time = st;
+        double_to_timeval(st, &start_time);
+
 	if (!read_activ_as_pi(&a)) {
 	    errlog("READ_TASK_QUEUE: Bad activation, count = %d.\n", count);
 	    return 0;
@@ -1283,16 +1422,17 @@
     }
     for (; suspended_count > 0; suspended_count--) {
 	task *t = (task *) mymalloc(sizeof(task), M_TASK);
-	int task_id, start_time;
+	int task_id;
+        double st;
 	char c;
 
 	t->kind = TASK_SUSPENDED;
-	if (dbio_scanf("%d %d%c", &start_time, &task_id, &c) != 3) {
+	if (dbio_scanf("%lf %d%c", &st, &task_id, &c) != 3) {
 	    errlog("READ_TASK_QUEUE: Bad suspended task header, count = %d\n",
 		   suspended_count);
 	    return 0;
 	}
-	t->t.suspended.start_time = start_time;
+        double_to_timeval(st, &t->t.suspended.start_time);
 	if (c == ' ')
 	    t->t.suspended.value = dbio_read_var();
 	else if (c == '\n')
@@ -1438,9 +1578,8 @@
     list.v.list[1].type = TYPE_INT;
     list.v.list[1].v.num = ft.id;
     list.v.list[2].type = TYPE_INT;
-    list.v.list[2].v.num = ft.start_time;
-    list.v.list[3].type = TYPE_INT;
-    list.v.list[3].v.num = 0;	/* OBSOLETE: was clock ID */
+    list.v.list[2].v.num = ft.start_time.tv_sec;
+    list.v.list[3] = new_float(timeval_to_double(&ft.start_time));	/* was clock ID, now float start time */
     list.v.list[4].type = TYPE_INT;
     list.v.list[4].v.num = DEFAULT_BG_TICKS;	/* OBSOLETE: was clock ticks */
     list.v.list[5].type = TYPE_OBJ;
@@ -1468,7 +1607,7 @@
     list.v.list[1].v.num = the_vm->task_id;
 
     list.v.list[3].type = TYPE_INT;
-    list.v.list[3].v.num = 0;	/* OBSOLETE: was clock ID */
+    list.v.list[3].v.num = 0;	/* was clock ID, now float start time (but not set here) */
     list.v.list[4].type = TYPE_INT;
     list.v.list[4].v.num = DEFAULT_BG_TICKS;	/* OBSOLETE: was clock ticks */
     list.v.list[5].type = TYPE_OBJ;
@@ -1492,7 +1631,8 @@
 
     list = list_for_vm(st.the_vm);
     list.v.list[2].type = TYPE_INT;
-    list.v.list[2].v.num = st.start_time;
+    list.v.list[2].v.num = st.start_time.tv_sec;
+    list.v.list[3] = new_float(timeval_to_double(&st.start_time));
 
     return list;
 }
@@ -1505,6 +1645,7 @@
     list = list_for_vm(the_vm);
     list.v.list[2].type = TYPE_INT;
     list.v.list[2].v.num = -1;	/* conventional value */
+    list.v.list[3] = new_float(0.0);
 
     list.v.list[5].v.obj = player;
 
@@ -1699,12 +1840,14 @@
     struct kcl_data *kdata = data;
 
     if (the_vm->task_id == kdata->id)
+    {
 	if (is_wizard(kdata->owner)
 	    || progr_of_cur_verb(the_vm) == kdata->owner) {
 	    free_vm(the_vm, 1);
 	    return TEA_KILL;
 	} else
 	    return TEA_STOP;
+    }
 
     return TEA_CONTINUE;
 }
@@ -1828,7 +1971,7 @@
 
 	if (!is_wizard(progr) && progr != owner)
 	    return E_PERM;
-	t->t.suspended.start_time = time(0);	/* runnable now */
+	double_to_timeval(0.0, &t->t.suspended.start_time);	/* runnable now */
 	free_var(t->t.suspended.value);
 	t->t.suspended.value = value;
 	tq = find_tqueue(owner, 1);
diff -Nur d20051106/projects/moo/src/tasks.h d20051107/projects/moo/src/tasks.h
--- d20051106/projects/moo/src/tasks.h	2004-03-22 11:14:54.000000000 -0500
+++ d20051107/projects/moo/src/tasks.h	2005-11-07 13:41:19.000000000 -0500
@@ -18,6 +18,8 @@
 #ifndef Tasks_H
 #define Tasks_H 1
 
+#include <sys/time.h>
+
 #include "config.h"
 #include "execute.h"
 #include "structures.h"
@@ -78,7 +80,7 @@
 
 extern Var read_input_now(Objid connection);
 
-extern int next_task_start(void);
+extern int next_task_start(struct timeval *tv);
 extern void run_ready_tasks(void);
 extern enum outcome run_server_task(Objid player, Objid what,
 				    const char *verb, Var args,
